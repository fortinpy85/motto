<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="44" skipped="8" tests="443" time="7448.349" timestamp="2025-11-09T08:54:46.429982-05:00" hostname="NUC-SERVER"><testcase classname="tests.chat.test_answer_sources" name="test_answer_sources" time="80.148" /><testcase classname="tests.chat.test_chat_models" name="test_create_chat" time="17.784" /><testcase classname="tests.chat.test_chat_models" name="test_chat_str" time="19.192" /><testcase classname="tests.chat.test_chat_models" name="test_chat_delete" time="22.246" /><testcase classname="tests.chat.test_chat_models" name="test_chat_manager_create_with_mode" time="19.206" /><testcase classname="tests.chat.test_chat_models" name="test_preset_creation_from_yaml" time="17.032" /><testcase classname="tests.chat.test_chat_options" name="test_chat_options" time="34.317" /><testcase classname="tests.chat.test_chat_options" name="test_library_list" time="48.509" /><testcase classname="tests.chat.test_chat_procs" name="test_url_to_text" time="24.212" /><testcase classname="tests.chat.test_chat_procs" name="test_fix_source_links" time="10.914" /><testcase classname="tests.chat.test_chat_procs" name="test_htmx_stream_response_stream" time="13.254"><failure message="django.db.utils.IntegrityError: duplicate key value violates unique constraint &quot;otto_user_upn_key&quot;&#10;DETAIL:  Key (upn)=(test_user_1.lastname@example.com) already exists.">self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C18290D70&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_1.lastname@example.com', 'test_user_1@example.com', 'test_user_1_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C18290D70&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_1.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: UniqueViolation

The above exception was the direct cause of the following exception:

all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C1276A520&gt;

    @pytest.mark.django_db
    @pytest.mark.asyncio
    async def test_htmx_stream_response_stream(all_apps_user):
        llm = OttoLLM(mock_embedding=True)
    
        async def stream_generator():
            for char in "Hi!":
                yield char
                await asyncio.sleep(0.1)
    
        # We first need an empty chat and a message
&gt;       user = await sync_to_async(all_apps_user)("test_user_1")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\chat\test_chat_procs.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:502: in __call__
    ret = await asyncio.shield(exec_coro)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:556: in thread_handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
django\tests\conftest.py:170: in new_user
    user = django_user_model.objects.create_user(
django\otto\models.py:22: in create_user
    user.save()
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\contrib\auth\base_user.py:65: in save
    super().save(*args, **kwargs)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:902: in save
    self.save_base(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1008: in save_base
    updated = self._save_table(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1169: in _save_table
    results = self._do_insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1210: in _do_insert
    return manager._insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:1868: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1882: in execute_sql
    cursor.execute(sql, params)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C18290D70&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_1.lastname@example.com', 'test_user_1@example.com', 'test_user_1_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C18290D70&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_1.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: IntegrityError</failure></testcase><testcase classname="tests.chat.test_chat_procs" name="test_htmx_stream_response_str" time="16.275"><failure message="django.db.utils.IntegrityError: duplicate key value violates unique constraint &quot;otto_user_upn_key&quot;&#10;DETAIL:  Key (upn)=(test_user_2.lastname@example.com) already exists.">self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C2864A6F0&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_2.lastname@example.com', 'test_user_2@example.com', 'test_user_2_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C2864A6F0&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_2.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: UniqueViolation

The above exception was the direct cause of the following exception:

all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C28323740&gt;

    @pytest.mark.asyncio
    @pytest.mark.django_db()
    async def test_htmx_stream_response_str(all_apps_user):
        llm = OttoLLM(mock_embedding=True)
        # We first need an empty chat and a message
&gt;       user = await sync_to_async(all_apps_user)("test_user_2")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\chat\test_chat_procs.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:502: in __call__
    ret = await asyncio.shield(exec_coro)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:556: in thread_handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
django\tests\conftest.py:170: in new_user
    user = django_user_model.objects.create_user(
django\otto\models.py:22: in create_user
    user.save()
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\contrib\auth\base_user.py:65: in save
    super().save(*args, **kwargs)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:902: in save
    self.save_base(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1008: in save_base
    updated = self._save_table(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1169: in _save_table
    results = self._do_insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1210: in _do_insert
    return manager._insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:1868: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1882: in execute_sql
    cursor.execute(sql, params)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C2864A6F0&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_2.lastname@example.com', 'test_user_2@example.com', 'test_user_2_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C2864A6F0&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_2.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: IntegrityError</failure></testcase><testcase classname="tests.chat.test_chat_procs" name="test_htmx_stream_response_generator" time="13.899"><failure message="django.db.utils.IntegrityError: duplicate key value violates unique constraint &quot;otto_user_upn_key&quot;&#10;DETAIL:  Key (upn)=(test_user_3.lastname@example.com) already exists.">self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181CCA10&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_3.lastname@example.com', 'test_user_3@example.com', 'test_user_3_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181CCA10&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_3.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: UniqueViolation

The above exception was the direct cause of the following exception:

all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C181A1B20&gt;

    @pytest.mark.asyncio
    @pytest.mark.django_db()
    async def test_htmx_stream_response_generator(all_apps_user):
        llm = OttoLLM(mock_embedding=True)
    
        class FakeFile:
            def __init__(self, name, text):
                self.name = name
                self.text = text
    
        async def stream_generator():
            files = [
                FakeFile("file1.txt", "This is the first file"),
                FakeFile("file2.txt", "This is the second file"),
            ]
            for i, file in enumerate(files):
                yield f"**{file.name}**\n"
                summary = await summarize_long_text_async(file.text, llm)
                if i &lt; len(files) - 1:
                    yield f"{summary}\n\n-----\n"
                else:
                    yield f"{summary}\n"
    
        # We first need an empty chat and a message
&gt;       user = await sync_to_async(all_apps_user)("test_user_3")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\chat\test_chat_procs.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:502: in __call__
    ret = await asyncio.shield(exec_coro)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:556: in thread_handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
django\tests\conftest.py:170: in new_user
    user = django_user_model.objects.create_user(
django\otto\models.py:22: in create_user
    user.save()
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\contrib\auth\base_user.py:65: in save
    super().save(*args, **kwargs)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:902: in save
    self.save_base(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1008: in save_base
    updated = self._save_table(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1169: in _save_table
    results = self._do_insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1210: in _do_insert
    return manager._insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:1868: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1882: in execute_sql
    cursor.execute(sql, params)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181CCA10&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_3.lastname@example.com', 'test_user_3@example.com', 'test_user_3_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181CCA10&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_3.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: IntegrityError</failure></testcase><testcase classname="tests.chat.test_chat_procs" name="test_htmx_stream_response_replacer" time="13.676"><failure message="django.db.utils.IntegrityError: duplicate key value violates unique constraint &quot;otto_user_upn_key&quot;&#10;DETAIL:  Key (upn)=(test_user_4.lastname@example.com) already exists.">self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181B19D0&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_4.lastname@example.com', 'test_user_4@example.com', 'test_user_4_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181B19D0&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_4.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: UniqueViolation

The above exception was the direct cause of the following exception:

basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C283B7560&gt;

    @pytest.mark.asyncio
    @pytest.mark.django_db()
    async def test_htmx_stream_response_replacer(basic_user):
        llm = OttoLLM(mock_embedding=True)
    
        async def stream_generator():
            yield "first thing"
            yield "second thing"
    
        # We first need an empty chat and a message
&gt;       user = await sync_to_async(basic_user)("test_user_4")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\chat\test_chat_procs.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:502: in __call__
    ret = await asyncio.shield(exec_coro)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asgiref\sync.py:556: in thread_handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
django\tests\conftest.py:187: in new_user
    user = django_user_model.objects.create_user(
django\otto\models.py:22: in create_user
    user.save()
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\contrib\auth\base_user.py:65: in save
    super().save(*args, **kwargs)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:902: in save
    self.save_base(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1008: in save_base
    updated = self._save_table(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1169: in _save_table
    results = self._do_insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:1210: in _do_insert
    return manager._insert(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:1868: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\sql\compiler.py:1882: in execute_sql
    cursor.execute(sql, params)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181B19D0&gt;
sql = 'INSERT INTO "otto_user" ("password", "last_login", "is_superuser", "upn", "email", "oid", "first_name", "last_name", ...leted") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "otto_user"."id"'
params = ('', None, False, 'test_user_4.lastname@example.com', 'test_user_4@example.com', 'test_user_4_oid', ...)
ignored_wrapper_args = (False, {'connection': &lt;DatabaseWrapper vendor='postgresql' alias='default'&gt;, 'cursor': &lt;django.db.backends.utils.CursorWrapper object at 0x0000021C181B19D0&gt;})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
&gt;               return self.cursor.execute(sql, params)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "otto_user_upn_key"
E               DETAIL:  Key (upn)=(test_user_4.lastname@example.com) already exists.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\backends\utils.py:105: IntegrityError</failure></testcase><testcase classname="tests.chat.test_chat_procs" name="test_combine_response_generators" time="13.903" /><testcase classname="tests.chat.test_chat_procs" name="test_combine_response_replacers" time="11.797" /><testcase classname="tests.chat.test_chat_procs" name="test_combine_batch_generators" time="11.922" /><testcase classname="tests.chat.test_chat_procs" name="test_get_chat_history_sections" time="20.394" /><testcase classname="tests.chat.test_chat_readonly" name="test_chat" time="33.914" /><testcase classname="tests.chat.test_chat_translate" name="test_translate_file" time="23.414"><failure message="Exception: Error translating C:\Users\barre\AppData\Local\Temp\tmp_q6z6ykf.txt">file_path = 'C:\\Users\\barre\\AppData\\Local\\Temp\\tmp_q6z6ykf.txt', target_language = 'fr-ca'
custom_translator_id = None, glossary_path = None

    @shared_task(soft_time_limit=ten_minutes)
    def translate_file(
        file_path, target_language, custom_translator_id=None, glossary_path=None
    ):
        if target_language == "fr":
            target_language = "fr-ca"
        try:
            from chat.models import ChatFile, Message
            from django.core.files.base import ContentFile
    
            with open(file_path, "rb") as f:
                file_content = f.read()
    
            llm = OttoLLM(deployment="gemini-1.5-flash")
            prompt = f"Translate the following document to {target_language}:\n\n{file_content.decode('utf-8')}"
            translated_text = llm.complete(prompt)
            llm.create_costs()
    
            file_name = file_path.split("/")[-1]
            file_extension = os.path.splitext(file_name)[1]
            file_name_without_extension = os.path.splitext(file_name)[0]
            output_file_name = (
                f"{file_name_without_extension}_{target_language.upper()}{file_extension}"
            )
    
            request_context = get_contextvars()
            out_message = Message.objects.get(id=request_context.get("message_id"))
    
            new_file = ChatFile.objects.create(
                message=out_message,
                filename=output_file_name,
                content_type="text/plain",
            )
&gt;           new_file.saved_file.file.save(
                output_file_name, ContentFile(translated_text.encode("utf-8"))
            )

django\chat\tasks.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\fields\files.py:99: in save
    self.name = self.storage.save(name, content, max_length=self.field.max_length)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\files\storage\base.py:49: in save
    name = self._save(name, content)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;django.core.files.storage.filesystem.FileSystemStorage object at 0x0000021C1276A0D0&gt;
name = 'files/2025/11/09/C:/Users/barre/AppData/Local/Temp/tmp_q6z6ykf_FR-CA.txt', content = &lt;ContentFile: Raw content&gt;

    def _save(self, name, content):
        full_path = self.path(name)
    
        # Create any intermediate directories that do not exist.
        directory = os.path.dirname(full_path)
        try:
            if self.directory_permissions_mode is not None:
                # Set the umask because os.makedirs() doesn't apply the "mode"
                # argument to intermediate-level directories.
                old_umask = os.umask(0o777 &amp; ~self.directory_permissions_mode)
                try:
                    os.makedirs(
                        directory, self.directory_permissions_mode, exist_ok=True
                    )
                finally:
                    os.umask(old_umask)
            else:
&gt;               os.makedirs(directory, exist_ok=True)
E               OSError: [WinError 123] The filename, directory name, or volume label syntax is incorrect: 'C:\\otto\\Otto\\django\\test_media\\files\\2025\\11\\09\\C:'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\files\storage\filesystem.py:100: OSError

During handling of the above exception, another exception occurred:

all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C2862B880&gt;

    @pytest.mark.django_db
    def test_translate_file(all_apps_user):
        """Test translate_file function with Gemini-based translation."""
        # Create a temporary file with content
        with tempfile.NamedTemporaryFile(
            delete=False, mode="w", suffix=".txt", encoding="utf-8"
        ) as temp_file:
            temp_file.write("Hello, this is a test file.")
            file_path = temp_file.name
    
        try:
            # Create a user and message for the test
            user = all_apps_user()
            chat = Chat.objects.create(user=user)
            in_message = Message.objects.create(chat=chat, text="Translate this")
            out_message = Message.objects.create(chat=chat, text="")
    
            # Mock OttoLLM
            mock_llm = mock.MagicMock()
            mock_llm.complete.return_value = "Bonjour, ceci est un fichier de test."
            mock_llm.create_costs.return_value = None
    
            # Mock contextvars to return the message ID
            get_contextvars = mock.MagicMock()
            get_contextvars.return_value = {"message_id": out_message.id}
    
            with (
                mock.patch("chat.tasks.OttoLLM", return_value=mock_llm),
                mock.patch("chat.tasks.get_contextvars", get_contextvars),
            ):
&gt;               translate_file(file_path, "fr")

django\tests\chat\test_chat_translate.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\celery\local.py:182: in __call__
    return self._get_current_object()(*a, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\celery\app\task.py:411: in __call__
    return self.run(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

file_path = 'C:\\Users\\barre\\AppData\\Local\\Temp\\tmp_q6z6ykf.txt', target_language = 'fr-ca'
custom_translator_id = None, glossary_path = None

    @shared_task(soft_time_limit=ten_minutes)
    def translate_file(
        file_path, target_language, custom_translator_id=None, glossary_path=None
    ):
        if target_language == "fr":
            target_language = "fr-ca"
        try:
            from chat.models import ChatFile, Message
            from django.core.files.base import ContentFile
    
            with open(file_path, "rb") as f:
                file_content = f.read()
    
            llm = OttoLLM(deployment="gemini-1.5-flash")
            prompt = f"Translate the following document to {target_language}:\n\n{file_content.decode('utf-8')}"
            translated_text = llm.complete(prompt)
            llm.create_costs()
    
            file_name = file_path.split("/")[-1]
            file_extension = os.path.splitext(file_name)[1]
            file_name_without_extension = os.path.splitext(file_name)[0]
            output_file_name = (
                f"{file_name_without_extension}_{target_language.upper()}{file_extension}"
            )
    
            request_context = get_contextvars()
            out_message = Message.objects.get(id=request_context.get("message_id"))
    
            new_file = ChatFile.objects.create(
                message=out_message,
                filename=output_file_name,
                content_type="text/plain",
            )
            new_file.saved_file.file.save(
                output_file_name, ContentFile(translated_text.encode("utf-8"))
            )
    
        except SoftTimeLimitExceeded:
            logger.error(f"Translation task timed out for {file_path}")
            raise Exception(f"Translation task timed out for {file_path}")
        except Exception as e:
            logger.exception(f"Error translating {file_path}: {e}")
&gt;           raise Exception(f"Error translating {file_path}")
E           Exception: Error translating C:\Users\barre\AppData\Local\Temp\tmp_q6z6ykf.txt

django\chat\tasks.py:102: Exception</failure></testcase><testcase classname="tests.chat.test_chat_translate_glossary" name="test_translate_glossary_upload_and_usage" time="89.020" /><testcase classname="tests.chat.test_chat_views" name="test_title_chat" time="18.998" /><testcase classname="tests.chat.test_chat_views" name="test_chat" time="35.975" /><testcase classname="tests.chat.test_chat_views" name="test_chat_message" time="18.987" /><testcase classname="tests.chat.test_chat_views" name="test_translate_file" time="24.632" /><testcase classname="tests.chat.test_chat_views" name="test_cost_warning" time="21.698" /><testcase classname="tests.chat.test_chat_views" name="test_chat_routes" time="18.164" /><testcase classname="tests.chat.test_chat_views" name="test_delete_chat" time="18.056" /><testcase classname="tests.chat.test_chat_views" name="test_delete_all_chats" time="21.081" /><testcase classname="tests.chat.test_chat_views" name="test_download_file" time="20.446"><failure message="assert 302 == 200&#10; +  where 302 = &lt;HttpResponseRedirect status_code=302, &quot;text/html; charset=utf-8&quot;, url=&quot;/&quot;&gt;.status_code">client = &lt;django.test.client.Client object at 0x0000021C28AB2F30&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C28AB3380&gt;

    @pytest.mark.django_db
    def test_download_file(client, all_apps_user):
        user = all_apps_user()
        client.force_login(user)
        # Write a file to translate called "test file.txt" with contents "Hello"
        with tempfile.TemporaryDirectory() as tmpdirname:
            with open(f"{tmpdirname}/test file.txt", "w") as file:
                file.write("Hello")
            chat = Chat.objects.create(user=user)
            in_message = Message.objects.create(chat=chat, text="")
            chat_file = ChatFile.objects.create(
                message=in_message,
                filename="test file.txt",
                eof=1,
                content_type="text/plain",
            )
            chat_file.saved_file.file.save(
                "test file.txt", open(f"{tmpdirname}/test file.txt", "rb")
            )
            file_id = chat_file.id
            url = reverse("chat:download_file", args=[file_id])
            response = client.get(url)
            assert response.status_code == 200
        # Note: In test/local mode, permission_required decorator is disabled
        # so even wrong_user can access the file
        wrong_user = all_apps_user("wrong_user")
        client.force_login(wrong_user)
        response = client.get(url)
        # In production, this would be 403 or 404, but in test mode permissions are bypassed
&gt;       assert response.status_code == 200
E       assert 302 == 200
E        +  where 302 = &lt;HttpResponseRedirect status_code=302, "text/html; charset=utf-8", url="/"&gt;.status_code

django\tests\chat\test_chat_views.py:418: AssertionError</failure></testcase><testcase classname="tests.chat.test_chat_views" name="test_chat_response" time="32.313" /><testcase classname="tests.chat.test_chat_views" name="test_chat_summarization_response" time="33.109" /><testcase classname="tests.chat.test_chat_views" name="test_translate_response" time="39.206" /><testcase classname="tests.chat.test_chat_views" name="test_qa_response" time="39.572" /><testcase classname="tests.chat.test_chat_views" name="test_qa_filters" time="35.366" /><testcase classname="tests.chat.test_chat_views" name="test_positive_thumbs_feedback" time="16.287" /><testcase classname="tests.chat.test_chat_views" name="test_negative_thumbs_feedback" time="16.654" /><testcase classname="tests.chat.test_chat_views" name="test_rename_chat_title" time="20.554" /><testcase classname="tests.chat.test_chat_views" name="test_per_source_qa_response" time="29.821" /><testcase classname="tests.chat.test_chat_views" name="test_summarize_qa_response" time="32.381" /><testcase classname="tests.chat.test_chat_views" name="test_preset" time="51.010" /><testcase classname="tests.chat.test_chat_views" name="test_update_qa_options_from_librarian" time="24.051" /><testcase classname="tests.chat.test_chat_views" name="test_chat_message_error" time="27.630" /><testcase classname="tests.chat.test_chat_views" name="test_chat_message_url_validation" time="16.723" /><testcase classname="tests.chat.test_chat_views" name="test_generate_prompt_view" time="20.880" /><testcase classname="tests.chat.test_chat_views" name="test_email_chat_author" time="16.310" /><testcase classname="tests.chat.test_chat_views" name="test_share_chat" time="15.784" /><testcase classname="tests.chat.test_glossary_filename_persistence" name="test_translate_glossary_filename_persists_on_refresh" time="19.688" /><testcase classname="tests.chat.test_highlights" name="test_mark_sentences" time="10.229" /><testcase classname="tests.chat.test_highlights" name="test_highlight_claims" time="11.663" /><testcase classname="tests.chat.test_highlights" name="test_highlight_claims_with_no_matches" time="9.728" /><testcase classname="tests.chat.test_highlights" name="test_highlight_claims_with_threshold" time="9.999" /><testcase classname="tests.chat.test_highlights" name="test_extract_claims_from_llm_tags_present" time="13.425" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_llm_model_creation" time="10.482" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_llm_model_localized_properties" time="9.354" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_llm_model_deprecated_flag" time="9.261" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_llm_model_inactive" time="9.285" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_llm_model_reasoning_flag" time="9.473" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_get_model_valid" time="9.476" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelConfiguration" name="test_get_model_invalid_returns_default" time="9.490" /><testcase classname="tests.chat.test_llm_edge_cases.TestOttoLLMInitialization" name="test_ottollm_default_initialization" time="12.422" /><testcase classname="tests.chat.test_llm_edge_cases.TestOttoLLMInitialization" name="test_ottollm_custom_deployment" time="12.385" /><testcase classname="tests.chat.test_llm_edge_cases.TestOttoLLMInitialization" name="test_ottollm_mock_embedding_mode" time="10.873" /><testcase classname="tests.chat.test_llm_edge_cases.TestOttoLLMInitialization" name="test_ottollm_missing_api_key_warning" time="9.061" /><testcase classname="tests.chat.test_llm_edge_cases.TestChatHistoryConversion" name="test_chat_history_to_prompt_empty" time="9.583" /><testcase classname="tests.chat.test_llm_edge_cases.TestChatHistoryConversion" name="test_chat_history_to_prompt_with_roles" time="9.168" /><testcase classname="tests.chat.test_llm_edge_cases.TestChatHistoryConversion" name="test_chat_history_to_prompt_with_dict" time="9.634" /><testcase classname="tests.chat.test_llm_edge_cases.TestTokenLimitHandling" name="test_model_token_limits_defined" time="9.291" /><testcase classname="tests.chat.test_llm_edge_cases.TestTokenLimitHandling" name="test_model_reasonable_token_limits" time="12.596" /><testcase classname="tests.chat.test_llm_edge_cases.TestCostTracking" name="test_cost_model_exists" time="10.171" /><testcase classname="tests.chat.test_llm_edge_cases.TestCostTracking" name="test_cost_tracking_called" time="9.441" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMErrorHandling" name="test_ottollm_handles_empty_prompt" time="13.374" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMErrorHandling" name="test_ottollm_handles_api_error" time="14.667" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMErrorHandling" name="test_ottollm_invalid_deployment_name" time="12.492" /><testcase classname="tests.chat.test_llm_edge_cases.TestMockLLMContext" name="test_mock_llm_context_default" time="9.515" /><testcase classname="tests.chat.test_llm_edge_cases.TestMockLLMContext" name="test_mock_llm_context_can_be_set" time="9.527" /><testcase classname="tests.chat.test_llm_edge_cases.TestMockLLMContext" name="test_mock_llm_context_isolation" time="9.620" /><testcase classname="tests.chat.test_llm_edge_cases.TestModelMetadata" name="test_models_have_descriptions" time="9.688" /><testcase classname="tests.chat.test_llm_edge_cases.TestModelMetadata" name="test_models_have_groups" time="9.715" /><testcase classname="tests.chat.test_llm_edge_cases.TestModelMetadata" name="test_system_prompt_customization" time="10.359" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelIntegration" name="test_models_by_id_populated" time="10.479" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelIntegration" name="test_default_chat_model_exists" time="10.601" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelIntegration" name="test_all_models_have_unique_ids" time="10.522" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMModelIntegration" name="test_all_models_have_unique_deployments" time="10.991" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMNegativeCases" name="test_llm_model_missing_required_fields" time="10.701" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMNegativeCases" name="test_llm_model_invalid_token_limits" time="10.447" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMNegativeCases" name="test_ottollm_with_none_deployment" time="10.433" /><testcase classname="tests.chat.test_llm_edge_cases.TestLLMNegativeCases" name="test_chat_history_with_malformed_data" time="10.555" /><testcase classname="tests.chat.test_llm_edge_cases.TestTimeoutAndRetry" name="test_retry_decorator_exists" time="10.517" /><testcase classname="tests.chat.test_llm_edge_cases.TestTimeoutAndRetry" name="test_ottollm_initialization_timeout" time="12.989" /><testcase classname="tests.chat.test_llm_edge_cases.TestModelProvider" name="test_model_provider_google" time="10.649" /><testcase classname="tests.chat.test_llm_edge_cases.TestModelProvider" name="test_model_provider_in_llm" time="11.547" /><testcase classname="tests.chat.test_message_pre_delete" name="test_message_pre_delete_removes_documents" time="28.427" /><testcase classname="tests.chat.test_message_pre_delete" name="test_message_pre_delete_non_qa_mode_no_deletion" time="18.305" /><testcase classname="tests.chat.test_message_pre_delete" name="test_message_pre_delete_multiple_documents" time="26.800" /><testcase classname="tests.chat.test_message_pre_delete" name="test_message_pre_delete_no_saved_file" time="18.187" /><testcase classname="tests.chat.test_message_pre_delete" name="test_message_pre_delete_error_handling" time="17.695" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_loading_monitor_view" time="31.308" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_loading_status_api" time="29.557" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_loading_start_post" time="29.765" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_loading_cancel_post" time="27.316" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_loading_cancel_when_not_running" time="27.302" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_list_view" time="27.224" /><testcase classname="tests.laws.test_laws_loading" name="test_job_status_singleton" time="21.486" /><testcase classname="tests.laws.test_laws_loading" name="test_job_status_cancel" time="21.156" /><testcase classname="tests.laws.test_laws_loading" name="test_law_model_creation" time="20.850" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_status_choices" time="21.558" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_status_label_translation" time="21.392" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_details_label_translation" time="21.011" /><testcase classname="tests.laws.test_laws_loading" name="test_get_sha_256_hash" time="21.473" /><testcase classname="tests.laws.test_laws_loading" name="test_get_dict_from_xml" time="21.199" /><testcase classname="tests.laws.test_laws_loading" name="test_small_laws_already_loaded" time="21.179" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_statuses_exist" time="21.070" /><testcase classname="tests.laws.test_laws_loading" name="test_laws_index" time="26.663" /><testcase classname="tests.laws.test_laws_loading" name="test_law_deletion_removes_from_vector_store" time="24.387" /><testcase classname="tests.laws.test_laws_loading" name="test_law_manager_purge_functionality" time="22.871" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_with_mock_embedding" time="21.948" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_task_integration" time="22.617" /><testcase classname="tests.laws.test_laws_loading" name="test_law_loading_task_with_download" time="24.683" /><testcase classname="tests.laws.test_laws_tasks" name="test_law_loading_with_mock_embedding" time="24.666" /><testcase classname="tests.laws.test_laws_tasks" name="test_law_loading_task_integration" time="28.878" /><testcase classname="tests.laws.test_laws_tasks" name="test_law_loading_task_with_download" time="24.464" /><testcase classname="tests.laws.test_laws_utils" name="test_get_law_url" time="29.062" /><testcase classname="tests.laws.test_laws_utils" name="test_format_llm_string" time="22.182" /><testcase classname="tests.laws.test_laws_utils" name="test_htmx_sse_response" time="21.612" /><testcase classname="tests.laws.test_laws_utils" name="test_htmx_sse_error" time="22.111" /><testcase classname="tests.laws.test_laws_utils" name="test_html_render" time="23.209" /><testcase classname="tests.laws.test_laws_views" name="test_laws_index" time="29.240" /><testcase classname="tests.laws.test_laws_views" name="test_laws_search_and_answer" time="37.004" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_pdf" time="8.668" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_pdf_gemini_read" time="22.164"><failure message="otto.models.CostType.DoesNotExist: CostType matching query does not exist.">@pytest.mark.django_db
    def test_extract_pdf_gemini_read():
        # Load a PDF file using Gemini OCR
        cost_count = Cost.objects.count()
        with open(os.path.join(this_dir, "test_files/example.pdf"), "rb") as f:
            content = f.read()
&gt;           extraction_result = extract_markdown(content, "PDF", pdf_method="gemini_read")
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\librarian\test_document_loading.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\utils\process_engine.py:307: in extract_markdown
    md = pdf_to_text_gemini_read(content)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\librarian\utils\process_engine.py:695: in pdf_to_text_gemini_read
    cost = Cost.objects.new(cost_type="gemini-ocr", count=len(text))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\otto\models.py:412: in new
    cost_type = CostType.objects.get(short_name=cost_type)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MultilingualQuerySet [&lt;CostType: GPT-4o Global (input)&gt;, &lt;CostType: GPT-4o Global (output)&gt;, &lt;CostType: OpenAI Embedd... (input)&gt;, &lt;CostType: o4-mini Global (output)&gt;, &lt;CostType: o3 Global (input)&gt;, '...(remaining elements truncated)...']&gt;
args = (), kwargs = {'short_name': 'gemini-ocr'}, clone = &lt;MultilingualQuerySet []&gt;, limit = 21, num = 0

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
&gt;           raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
E           otto.models.CostType.DoesNotExist: CostType matching query does not exist.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:633: DoesNotExist</failure></testcase><testcase classname="tests.librarian.test_document_loading" name="test_extract_pdf_gemini_layout" time="22.660"><failure message="otto.models.CostType.DoesNotExist: CostType matching query does not exist.">@pytest.mark.django_db
    def test_extract_pdf_gemini_layout():
        # Load a PDF file using Gemini OCR with layout
        cost_count = Cost.objects.count()
        with open(os.path.join(this_dir, "test_files/example.pdf"), "rb") as f:
            content = f.read()
&gt;           extraction_result = extract_markdown(content, "PDF", pdf_method="gemini_layout")
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\librarian\test_document_loading.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\utils\process_engine.py:309: in extract_markdown
    md = pdf_to_markdown_via_html_gemini_layout(content)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\librarian\utils\process_engine.py:425: in pdf_to_markdown_via_html_gemini_layout
    html = _pdf_to_html_gemini_layout(content)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\librarian\utils\process_engine.py:652: in _pdf_to_html_gemini_layout
    cost = Cost.objects.new(cost_type="gemini-ocr", count=len(html))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\otto\models.py:412: in new
    cost_type = CostType.objects.get(short_name=cost_type)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MultilingualQuerySet [&lt;CostType: Azure custom translation&gt;, &lt;CostType: GPT-4o Global (input)&gt;, &lt;CostType: GPT-4o Glob... (input)&gt;, &lt;CostType: o4-mini Global (output)&gt;, &lt;CostType: o3 Global (input)&gt;, '...(remaining elements truncated)...']&gt;
args = (), kwargs = {'short_name': 'gemini-ocr'}, clone = &lt;MultilingualQuerySet []&gt;, limit = 21, num = 0

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
&gt;           raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
E           otto.models.CostType.DoesNotExist: CostType matching query does not exist.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:633: DoesNotExist</failure></testcase><testcase classname="tests.librarian.test_document_loading" name="test_extract_pptx" time="10.582" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_docx" time="9.071" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_text" time="8.778" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_outlook_msg" time="23.314" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_eml" time="20.654" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_png" time="0.000"><skipped type="pytest.skip" message="Gemini API limitation: PNG files return 'The document has no pages' error">C:\otto\Otto\django\tests\librarian\test_document_loading.py:219: Gemini API limitation: PNG files return 'The document has no pages' error</skipped></testcase><testcase classname="tests.librarian.test_document_loading" name="test_extract_zip" time="39.430" /><testcase classname="tests.librarian.test_document_loading" name="test_resize_image_for_ocr" time="12.337" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_csv" time="10.475" /><testcase classname="tests.librarian.test_document_loading" name="test_extract_excel" time="9.197" /><testcase classname="tests.librarian.test_document_loading" name="test_decode_content_utf8" time="9.001" /><testcase classname="tests.librarian.test_document_loading" name="test_decode_content_cp1252" time="9.689" /><testcase classname="tests.librarian.test_document_loading" name="test_decode_content_with_custom_encodings" time="10.350" /><testcase classname="tests.librarian.test_file_uploads" name="test_docx_to_markdown_success" time="9.411" /><testcase classname="tests.librarian.test_file_uploads" name="test_docx_to_markdown_corrupted" time="8.839" /><testcase classname="tests.librarian.test_file_uploads" name="test_pptx_to_markdown_success" time="8.948" /><testcase classname="tests.librarian.test_file_uploads" name="test_pptx_to_markdown_corrupted" time="9.724" /><testcase classname="tests.librarian.test_file_uploads" name="test_excel_to_markdown_success" time="8.959" /><testcase classname="tests.librarian.test_file_uploads" name="test_excel_to_markdown_corrupted" time="9.693" /><testcase classname="tests.librarian.test_file_uploads" name="test_csv_to_markdown_success" time="10.127" /><testcase classname="tests.librarian.test_file_uploads" name="test_csv_to_markdown_corrupted" time="8.794" /><testcase classname="tests.librarian.test_file_uploads" name="test_pdf_to_text_corrupted" time="9.385" /><testcase classname="tests.librarian.test_file_uploads" name="test_empty_csv" time="8.747" /><testcase classname="tests.librarian.test_file_uploads" name="test_empty_excel" time="9.516" /><testcase classname="tests.librarian.test_file_uploads" name="test_markdown_table_formatting" time="9.975" /><testcase classname="tests.librarian.test_file_uploads" name="test_multiple_excel_sheets" time="9.819" /><testcase classname="tests.librarian.test_librarian" name="test_editable_library_list_and_library_form" time="52.481" /><testcase classname="tests.librarian.test_librarian" name="test_modal_library_list" time="17.154" /><testcase classname="tests.librarian.test_librarian" name="test_modal_create_library_get" time="19.911" /><testcase classname="tests.librarian.test_librarian" name="test_modal_create_library_post" time="20.244" /><testcase classname="tests.librarian.test_librarian" name="test_modal_view_library_get" time="29.521" /><testcase classname="tests.librarian.test_librarian" name="test_modal_edit_library_get_redirect" time="21.787" /><testcase classname="tests.librarian.test_librarian" name="test_chat_data_source" time="55.838"><skipped type="pytest.xfail" message="Windows file handle locking: HTTP response file handles persist beyond reasonable retry windows in test environment. Application logic is correct - file deletion works in production." /></testcase><testcase classname="tests.librarian.test_librarian" name="test_start_stop" time="36.121" /><testcase classname="tests.librarian.test_librarian" name="test_modal_views" time="28.029" /><testcase classname="tests.librarian.test_librarian" name="test_poll_status" time="14.157" /><testcase classname="tests.librarian.test_librarian" name="test_document_url_validation" time="13.710" /><testcase classname="tests.librarian.test_librarian" name="test_email_library_admins" time="13.447" /><testcase classname="tests.librarian.test_librarian_models" name="test_create_library" time="14.546" /><testcase classname="tests.librarian.test_librarian_models" name="test_create_data_source" time="13.724"><failure message="chat.models.Preset.MultipleObjectsReturned: get() returned more than one Preset -- it returned 2!">@pytest.mark.django_db
    def test_create_data_source():
        """
        Tests the creation of a DataSource object.
        """
        # Use get_or_create to avoid duplicate key errors with fixtures
        SecurityLabel.objects.get_or_create(name="Unclassified", defaults={"acronym_en": "UC"})
        user = User.objects.create_user(upn="testuser@example.com", email="testuser@example.com")
        options = ChatOptions.objects.create()
        preset, _ = Preset.objects.get_or_create(name_en="Default", defaults={"options": options, "english_default": True})
&gt;       chat = Chat.objects.create(user=user)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

django\tests\librarian\test_librarian_models.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\chat\models.py:94: in create
    ChatOptions.objects.from_defaults(
django\chat\models.py:147: in from_defaults
    default_preset = Preset.objects.get_global_default()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\chat\models.py:335: in get_global_default
    return self.get(english_default=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;QuerySet [&lt;Preset: Preset 5145: Otto default (English)&gt;, &lt;Preset: Preset 5146: Otto default (French)&gt;, &lt;Preset: Prese...reset: Preset 5157: Translate to English&gt;, &lt;Preset: Preset 5158: Translate to French&gt;, &lt;Preset: Preset 5159: Default&gt;]&gt;
args = (), kwargs = {'english_default': True}
clone = &lt;QuerySet [&lt;Preset: Preset 5145: Otto default (English)&gt;, &lt;Preset: Preset 5159: Default&gt;]&gt;, limit = 21, num = 2

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
            raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
&gt;       raise self.model.MultipleObjectsReturned(
            "get() returned more than one %s -- it returned %s!"
            % (
                self.model._meta.object_name,
                num if not limit or num &lt; limit else "more than %s" % (limit - 1),
            )
        )
E       chat.models.Preset.MultipleObjectsReturned: get() returned more than one Preset -- it returned 2!

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:636: MultipleObjectsReturned</failure></testcase><testcase classname="tests.librarian.test_markdown_splitter" name="test_split_with_page_numbers_no_page_tags" time="8.531" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_split_with_page_numbers_single_page_tag" time="8.290" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_split_with_page_numbers_multiple_page_tags" time="8.502" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_split_with_page_numbers_no_content_between_page_tags" time="29.281" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_split_with_page_numbers_overlap" time="8.674" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_close_page_tags_simple" time="8.522" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_close_page_tags_complex_1" time="8.949" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_close_page_tags_complex_2" time="8.763" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_heading" time="8.684" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_set_headings" time="9.516" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_prepend_headings" time="13.624" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_all_headings_1" time="9.563" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_all_headings_2" time="10.403" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_all_headings_3" time="9.314" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_table_heading_helpers" time="9.386" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_1" time="9.338" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_2" time="9.823" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_3" time="9.289" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_4" time="9.255" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_5" time="9.147" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_6" time="9.310" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_get_last_table_header_7" time="9.224" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_table_header_1" time="9.157" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_table_header_2" time="9.624" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_table_header_3" time="9.398" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_table_header_4" time="9.260" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_table_header_5" time="9.291" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_repeat_headings" time="9.185" /><testcase classname="tests.librarian.test_markdown_splitter" name="test_markdown_splitter_no_page_numbers" time="12.636" /><testcase classname="tests.otto.test_auth_integration.TestUserAuthentication" name="test_user_creation_with_upn" time="20.303" /><testcase classname="tests.otto.test_auth_integration.TestUserAuthentication" name="test_user_authentication_with_upn" time="15.882" /><testcase classname="tests.otto.test_auth_integration.TestUserAuthentication" name="test_user_personal_library_creation" time="14.961" /><testcase classname="tests.otto.test_auth_integration.TestUserAuthentication" name="test_superuser_creation" time="15.420" /><testcase classname="tests.otto.test_auth_integration.TestTermsAcceptance" name="test_user_without_accepted_terms" time="15.363" /><testcase classname="tests.otto.test_auth_integration.TestTermsAcceptance" name="test_user_with_accepted_terms" time="14.997" /><testcase classname="tests.otto.test_auth_integration.TestTermsAcceptance" name="test_terms_permission_gates_access" time="20.669" /><testcase classname="tests.otto.test_auth_integration.TestGroupBasedAuthorization" name="test_otto_admin_group_membership" time="15.205"><failure message="assert False&#10; +  where False = is_admin(&lt;User: ,  (basic_user@example.com)&gt;)">self = &lt;test_auth_integration.TestGroupBasedAuthorization object at 0x0000021C10F60190&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38CCE8E0&gt;

    def test_otto_admin_group_membership(self, basic_user):
        """Test Otto admin group membership check"""
        user = basic_user()
        admin_group = Group.objects.get(name="Otto admin")
    
        # User not admin initially
        assert not user.is_admin
        assert not is_admin(user)
    
        # Add to admin group
        user.groups.add(admin_group)
        user.refresh_from_db()
    
        assert user.is_admin
&gt;       assert is_admin(user)
E       assert False
E        +  where False = is_admin(&lt;User: ,  (basic_user@example.com)&gt;)

django\tests\otto\test_auth_integration.py:151: AssertionError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestGroupBasedAuthorization" name="test_operations_admin_group" time="15.292" /><testcase classname="tests.otto.test_auth_integration.TestGroupBasedAuthorization" name="test_data_steward_permissions" time="17.140"><failure message="AssertionError: assert False&#10; +  where False = has_perm('librarian.manage_public_libraries')&#10; +    where has_perm = &lt;User: ,  (basic_user@example.com)&gt;.has_perm">self = &lt;test_auth_integration.TestGroupBasedAuthorization object at 0x0000021C10CB9F30&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38BD2980&gt;

    def test_data_steward_permissions(self, basic_user):
        """Test Data steward group permissions"""
        user = basic_user()
        steward_group, _ = Group.objects.get_or_create(name="Data steward")
    
        # Initially cannot manage public libraries
        assert not user.has_perm("librarian.manage_public_libraries")
    
        # Add to data steward group
        user.groups.add(steward_group)
        user.refresh_from_db()
    
&gt;       assert user.has_perm("librarian.manage_public_libraries")
E       AssertionError: assert False
E        +  where False = has_perm('librarian.manage_public_libraries')
E        +    where has_perm = &lt;User: ,  (basic_user@example.com)&gt;.has_perm

django\tests\otto\test_auth_integration.py:179: AssertionError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestGroupBasedAuthorization" name="test_make_otto_admin_method" time="14.949" /><testcase classname="tests.otto.test_auth_integration.TestAppAccessAuthorization" name="test_view_app_public" time="15.054" /><testcase classname="tests.otto.test_auth_integration.TestAppAccessAuthorization" name="test_view_app_restricted_no_group" time="14.846" /><testcase classname="tests.otto.test_auth_integration.TestAppAccessAuthorization" name="test_view_app_restricted_with_group" time="14.954" /><testcase classname="tests.otto.test_auth_integration.TestAppAccessAuthorization" name="test_admin_can_view_all_apps" time="15.257" /><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_user_can_access_own_chat" time="14.829" /><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_user_cannot_access_other_chat" time="21.293" /><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_preset_sharing_everyone" time="20.448"><failure message="TypeError: Preset() got unexpected keyword arguments: 'name'">self = &lt;test_auth_integration.TestChatAccessAuthorization object at 0x0000021C10CBA520&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38D16AC0&gt;

    def test_preset_sharing_everyone(self, basic_user):
        """Test preset shared with everyone"""
        owner = basic_user(username="owner", accept_terms=True)
        other_user = basic_user(username="other", accept_terms=True)
    
        options = ChatOptions.objects.create()
&gt;       preset = Preset.objects.create(
            owner=owner,
            name="Public Preset",
            options=options,
            sharing_option="everyone"
        )

django\tests\otto\test_auth_integration.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Preset: Preset None: &gt;, args = (), kwargs = {'name': 'Public Preset'}, cls = &lt;class 'chat.models.Preset'&gt;
opts = &lt;Options for Preset&gt;, _setattr = &lt;built-in function setattr&gt;, _DEFERRED = &lt;Deferred field&gt;
fields_iter = &lt;tuple_iterator object at 0x0000021C38C5B6D0&gt;, val = False
field = &lt;django.db.models.fields.BooleanField: french_default&gt;, is_related_object = False
rel_obj = &lt;User: ,  (owner@example.com)&gt;
property_names = frozenset({'description_auto', 'global_default', 'name_auto', 'pk', 'shared_with'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Preset() got unexpected keyword arguments: 'name'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_preset_sharing_specific_users" time="28.596"><failure message="TypeError: Preset() got unexpected keyword arguments: 'name'">self = &lt;test_auth_integration.TestChatAccessAuthorization object at 0x0000021C10CBA3F0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38D15800&gt;

    def test_preset_sharing_specific_users(self, basic_user):
        """Test preset shared with specific users"""
        owner = basic_user(username="owner", accept_terms=True)
        allowed_user = basic_user(username="allowed", accept_terms=True)
        blocked_user = basic_user(username="blocked", accept_terms=True)
    
        options = ChatOptions.objects.create()
&gt;       preset = Preset.objects.create(
            owner=owner,
            name="Shared Preset",
            options=options,
            sharing_option="specific"
        )

django\tests\otto\test_auth_integration.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Preset: Preset None: &gt;, args = (), kwargs = {'name': 'Shared Preset'}, cls = &lt;class 'chat.models.Preset'&gt;
opts = &lt;Options for Preset&gt;, _setattr = &lt;built-in function setattr&gt;, _DEFERRED = &lt;Deferred field&gt;
fields_iter = &lt;tuple_iterator object at 0x0000021C38CB4700&gt;, val = False
field = &lt;django.db.models.fields.BooleanField: french_default&gt;, is_related_object = False
rel_obj = &lt;User: ,  (owner@example.com)&gt;
property_names = frozenset({'description_auto', 'global_default', 'name_auto', 'pk', 'shared_with'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Preset() got unexpected keyword arguments: 'name'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_preset_edit_permissions" time="29.497"><failure message="TypeError: Preset() got unexpected keyword arguments: 'name'">self = &lt;test_auth_integration.TestChatAccessAuthorization object at 0x0000021C10E86B10&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38CEEE80&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C38CEC7C0&gt;

    def test_preset_edit_permissions(self, basic_user, all_apps_user):
        """Test preset edit permissions"""
        owner = basic_user(username="owner", accept_terms=True)
        other_user = basic_user(username="other", accept_terms=True)
        admin = all_apps_user()
    
        options = ChatOptions.objects.create()
&gt;       preset = Preset.objects.create(
            owner=owner,
            name="User Preset",
            options=options
        )

django\tests\otto\test_auth_integration.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Preset: Preset None: &gt;, args = (), kwargs = {'name': 'User Preset'}, cls = &lt;class 'chat.models.Preset'&gt;
opts = &lt;Options for Preset&gt;, _setattr = &lt;built-in function setattr&gt;, _DEFERRED = &lt;Deferred field&gt;
fields_iter = &lt;tuple_iterator object at 0x0000021C38B49A50&gt;, val = False
field = &lt;django.db.models.fields.BooleanField: french_default&gt;, is_related_object = False
rel_obj = &lt;User: ,  (owner@example.com)&gt;
property_names = frozenset({'description_auto', 'global_default', 'name_auto', 'pk', 'shared_with'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Preset() got unexpected keyword arguments: 'name'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestChatAccessAuthorization" name="test_global_default_preset_restrictions" time="23.454"><failure message="TypeError: Preset() got unexpected keyword arguments: 'name'">self = &lt;test_auth_integration.TestChatAccessAuthorization object at 0x0000021C10C66360&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C38CDCEA0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38D0CE00&gt;

    def test_global_default_preset_restrictions(self, all_apps_user, basic_user):
        """Test that global default presets have special restrictions"""
        admin = all_apps_user()
        user = basic_user(accept_terms=True)
    
        options = ChatOptions.objects.create()
&gt;       global_preset = Preset.objects.create(
            owner=None,
            name="Global Default",
            options=options,
            english_default=True
        )

django\tests\otto\test_auth_integration.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Preset: Preset None: &gt;, args = (), kwargs = {'name': 'Global Default'}, cls = &lt;class 'chat.models.Preset'&gt;
opts = &lt;Options for Preset&gt;, _setattr = &lt;built-in function setattr&gt;, _DEFERRED = &lt;Deferred field&gt;
fields_iter = &lt;tuple_iterator object at 0x0000021C38C0DC30&gt;, val = False
field = &lt;django.db.models.fields.BooleanField: french_default&gt;, is_related_object = False, rel_obj = None
property_names = frozenset({'description_auto', 'global_default', 'name_auto', 'pk', 'shared_with'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Preset() got unexpected keyword arguments: 'name'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_public_library_view_access" time="21.981" /><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_private_library_view_access" time="29.559" /><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_library_edit_permissions" time="33.677" /><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_library_delete_permissions" time="28.612" /><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_personal_library_restrictions" time="16.173" /><testcase classname="tests.otto.test_auth_integration.TestLibraryAccessAuthorization" name="test_manage_library_users_permission" time="35.534"><failure message="AssertionError: assert False&#10; +  where False = has_perm('librarian.manage_library_users', &lt;Library: Managed Library&gt;)&#10; +    where has_perm = &lt;User: ,  (all_apps_user@example.com)&gt;.has_perm">self = &lt;test_auth_integration.TestLibraryAccessAuthorization object at 0x0000021C10C66690&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C38D0DA80&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C38D0DB20&gt;

    def test_manage_library_users_permission(self, basic_user, all_apps_user):
        """Test managing library users permission"""
        library_admin = basic_user(username="lib_admin")
        contributor = basic_user(username="contributor")
        otto_admin = all_apps_user()
    
        library = Library.objects.create(
            name="Managed Library",
            is_public=False,
            created_by=library_admin
        )
    
        LibraryUserRole.objects.create(user=library_admin, library=library, role="admin")
        LibraryUserRole.objects.create(user=contributor, library=library, role="contributor")
    
        # Library admin can manage users
        assert can_manage_library_users(library_admin, library)
    
        # Contributor cannot manage users
        assert not can_manage_library_users(contributor, library)
    
        # Otto admin can manage users on any library
&gt;       assert otto_admin.has_perm("librarian.manage_library_users", library)
E       AssertionError: assert False
E        +  where False = has_perm('librarian.manage_library_users', &lt;Library: Managed Library&gt;)
E        +    where has_perm = &lt;User: ,  (all_apps_user@example.com)&gt;.has_perm

django\tests\otto\test_auth_integration.py:473: AssertionError</failure></testcase><testcase classname="tests.otto.test_auth_integration.TestAuthorizationDecorators" name="test_permission_required_decorator_allows_access" time="16.821" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationDecorators" name="test_budget_required_decorator_blocks_over_budget" time="18.528" /><testcase classname="tests.otto.test_auth_integration.TestAdministrativePermissions" name="test_admin_can_manage_users" time="16.372" /><testcase classname="tests.otto.test_auth_integration.TestAdministrativePermissions" name="test_admin_can_load_laws" time="15.024" /><testcase classname="tests.otto.test_auth_integration.TestAdministrativePermissions" name="test_admin_can_manage_feedback" time="16.826" /><testcase classname="tests.otto.test_auth_integration.TestAdministrativePermissions" name="test_operations_admin_can_manage_feedback" time="16.763" /><testcase classname="tests.otto.test_auth_integration.TestAdministrativePermissions" name="test_regular_user_cannot_access_admin_features" time="15.816" /><testcase classname="tests.otto.test_auth_integration.TestMultiUserScenarios" name="test_collaborative_library_access" time="44.675" /><testcase classname="tests.otto.test_auth_integration.TestMultiUserScenarios" name="test_chat_isolation_between_users" time="27.143" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationEdgeCases" name="test_user_without_groups" time="15.479" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationEdgeCases" name="test_user_deletion_cascades_library" time="15.085" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationEdgeCases" name="test_library_role_caching" time="21.737" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationEdgeCases" name="test_app_without_user_group" time="15.088" /><testcase classname="tests.otto.test_auth_integration.TestAuthorizationEdgeCases" name="test_budget_calculation_with_exchange_rate" time="14.346" /><testcase classname="tests.otto.test_budget" name="test_get_user_cost" time="14.008" /><testcase classname="tests.otto.test_budget" name="test_exceed_budget" time="20.398" /><testcase classname="tests.otto.test_celery_beat" name="test_celery_beat_schedule_loads_all_tasks" time="8.674" /><testcase classname="tests.otto.test_cleanup" name="test_redundant_librarian_upload" time="52.937"><failure message="assert 2 == 1&#10; +  where 2 = count()&#10; +    where count = &lt;QuerySet [&lt;SavedFile: files/2025/11/08/JUS_EN-FR_naukiKt.csv&gt;, &lt;SavedFile: files/2025/11/09/test_cleanup.py&gt;]&gt;.count">client = &lt;django.test.client.Client object at 0x0000021C308FA490&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C38E1BA60&gt;

    @pytest.mark.django_db
    def test_redundant_librarian_upload(client, all_apps_user):
        """
        Upload a file through Librarian modal.
        Check media directory
        Upload same file again.
        Check media directory - still should be just 1 instance of the file though there are now 2 documents
        Delete one of the documents in Librarian modal.
        File should still be there, since there is a reference from the other Document object.
        Delete the other Document
        File should be gone now.
        """
        user = all_apps_user()
        client.force_login(user)
        # Create a DataSource in the user library (manually)
        user_library = user.personal_library
        data_source = DataSource.objects.create(
            library=user_library,
            name="Test Data Source",
        )
        upload_url = reverse(
            "librarian:direct_upload", kwargs={"data_source_id": data_source.id}
        )
        # Get initial count of SavedFile objects (may include preset CSV files)
        initial_saved_files_count = SavedFile.objects.count()
    
        # Test uploading this file
        this_file_path = os.path.abspath(__file__)
        with open(this_file_path, "rb") as f:
            response = client.post(upload_url, {"file": f})
            assert response.status_code == 200
        # Check SavedFile created (should be 1 more than initial)
        saved_files = SavedFile.objects.all()
        assert saved_files.count() == initial_saved_files_count + 1
        # Check Document created
        documents = data_source.documents.all()
        assert documents.count() == 1
        # Get the newly created SavedFile (should be the most recent one)
        test_saved_file = saved_files.order_by("-id").first()
        # Check media directory
        assert os.path.exists(test_saved_file.file.path)
        # Upload the same file again
        with open(this_file_path, "rb") as f:
            response = client.post(upload_url, {"file": f})
            assert response.status_code == 200
        # Check SavedFile NOT created (count should remain the same)
        saved_files = SavedFile.objects.all()
        assert saved_files.count() == initial_saved_files_count + 1
        # A document should NOT have been created since hash, filename and data source are the same
        documents = data_source.documents.all()
        assert documents.count() == 1
        # Now, change the filename and upload again
        # First, copy this file to a different name
        new_file_path = os.path.join(os.path.dirname(this_file_path), "new_file_name.txt")
        shutil.copy(this_file_path, new_file_path)
        with open(new_file_path, "rb") as f:
            response = client.post(upload_url, {"file": f})
            assert response.status_code == 200
        # Delete the file
        os.remove(new_file_path)
        # Check SavedFile NOT created (count should remain the same)
        saved_files = SavedFile.objects.all()
        assert saved_files.count() == initial_saved_files_count + 1
        # A document should have been created since the filename is different
        documents = data_source.documents.all()
        assert documents.count() == 2
        # Check that both documents reference the same SavedFile
        assert documents.first().saved_file == documents.last().saved_file
        # Check media directory. There should be only 1 test file (plus any preset files)
        folder = os.path.dirname(test_saved_file.file.path)
        test_files = [f for f in os.listdir(folder) if f.endswith(".py")]
        assert len(test_files) == 1
        # Delete one of the documents
        document = documents.first()
        document.delete()
        # Check SavedFile still exists (count should remain the same)
        saved_files = SavedFile.objects.all()
        assert saved_files.count() == initial_saved_files_count + 1
        # Check media directory
        assert os.path.exists(test_saved_file.file.path)
        # Delete the other document
        document = documents.last()
        document.delete()
        # Check test SavedFile is gone (count should be back to initial)
        saved_files = SavedFile.objects.all()
&gt;       assert saved_files.count() == initial_saved_files_count
E       assert 2 == 1
E        +  where 2 = count()
E        +    where count = &lt;QuerySet [&lt;SavedFile: files/2025/11/08/JUS_EN-FR_naukiKt.csv&gt;, &lt;SavedFile: files/2025/11/09/test_cleanup.py&gt;]&gt;.count

django\tests\otto\test_cleanup.py:116: AssertionError</failure></testcase><testcase classname="tests.otto.test_cleanup" name="test_reset_monthly_bonus_task" time="14.111" /><testcase classname="tests.otto.test_cleanup" name="test_delete_old_chats_task" time="20.596" /><testcase classname="tests.otto.test_cleanup" name="test_delete_unused_libraries_task" time="43.892" /><testcase classname="tests.otto.test_cleanup" name="test_warn_libraries_pending_deletion_task" time="37.675" /><testcase classname="tests.otto.test_cleanup" name="test_delete_empty_chats_task" time="14.680" /><testcase classname="tests.otto.test_commands_delete_translation_files" name="test_handle_no_files" time="0.000"><skipped type="pytest.skip" message="Azure translation services deprecated - command only logs warning now">C:\otto\Otto\django\tests\otto\test_commands_delete_translation_files.py:8: Azure translation services deprecated - command only logs warning now</skipped></testcase><testcase classname="tests.otto.test_commands_delete_translation_files" name="test_handle_with_translation_files" time="0.000"><skipped type="pytest.skip" message="Azure translation services deprecated - command only logs warning now">C:\otto\Otto\django\tests\otto\test_commands_delete_translation_files.py:20: Azure translation services deprecated - command only logs warning now</skipped></testcase><testcase classname="tests.otto.test_commands_delete_translation_files" name="test_handle_list_error" time="0.000"><skipped type="pytest.skip" message="Azure translation services deprecated - command only logs warning now">C:\otto\Otto\django\tests\otto\test_commands_delete_translation_files.py:38: Azure translation services deprecated - command only logs warning now</skipped></testcase><testcase classname="tests.otto.test_commands_delete_translation_files" name="test_handle_delete_error" time="0.000"><skipped type="pytest.skip" message="Azure translation services deprecated - command only logs warning now">C:\otto\Otto\django\tests\otto\test_commands_delete_translation_files.py:51: Azure translation services deprecated - command only logs warning now</skipped></testcase><testcase classname="tests.otto.test_exchange_rate_update" name="test_exchange_rate_update" time="10.047" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_dashboard_view" time="14.705" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_stats_view" time="14.703" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_list_view" time="15.187" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_dashboard_update_metadata" time="15.546" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_dashboard_update_notes" time="14.160" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_dashboard_update" time="14.071" /><testcase classname="tests.otto.test_feedback_dashboard" name="test_feedback_download_view" time="15.278" /><testcase classname="tests.otto.test_load_test" name="test_enabling_load_test" time="19.847" /><testcase classname="tests.otto.test_load_test" name="test_load_tests" time="18.250"><failure message="sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) &lt;class 'asyncpg.exceptions.UndefinedTableError'&gt;: relation &quot;public.data_laws_lois__&quot; does not exist&#10;[SQL: SELECT public.data_laws_lois__.id, public.data_laws_lois__.node_id, public.data_laws_lois__.text, public.data_laws_lois__.metadata_, ts_rank(public.data_laws_lois__.text_search_tsv, to_tsquery($1, $2::VARCHAR)) AS rank &#10;FROM public.data_laws_lois__ &#10;WHERE public.data_laws_lois__.text_search_tsv @@ to_tsquery($1, $2::VARCHAR) ORDER BY rank desc &#10; LIMIT $3::INTEGER]&#10;[parameters: ('english', 'query|string', 100)]&#10;(Background on this error at: https://sqlalche.me/e/20/f405)">self = &lt;sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x0000021C393D03A0&gt;
operation = 'SELECT public.data_laws_lois__.id, public.data_laws_lois__.node_id, public.data_laws_lois__.text, public.data_laws_lo...\nWHERE public.data_laws_lois__.text_search_tsv @@ to_tsquery($1, $2::VARCHAR) ORDER BY rank desc \n LIMIT $3::INTEGER'
parameters = ('english', 'query|string', 100)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
&gt;               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:768: in _prepare
    prepared_stmt = await self._connection.prepare(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asyncpg\connection.py:635: in prepare
    return await self._prepare(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asyncpg\connection.py:653: in _prepare
    stmt = await self._get_statement(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\asyncpg\connection.py:432: in _get_statement
    statement = await self._protocol.prepare(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   asyncpg.exceptions.UndefinedTableError: relation "public.data_laws_lois__" does not exist

asyncpg\\protocol\\protocol.pyx:165: UndefinedTableError

The above exception was the direct cause of the following exception:

self = &lt;sqlalchemy.engine.base.Connection object at 0x0000021C393EC590&gt;
dialect = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x0000021C38D6E520&gt;
context = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x0000021C38E5EAD0&gt;
statement = &lt;sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x0000021C38BA25D0&gt;
parameters = [('english', 'query|string', 100)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:580: in execute
    self._adapt_connection.await_(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:558: in _prepare_and_execute
    self._handle_exception(error)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:508: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0x0000021C3941F980&gt;&gt;
error = UndefinedTableError('relation "public.data_laws_lois__" does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: &lt;class 'asyncpg.exceptions.UndefinedTableError'&gt;: relation "public.data_laws_lois__" does not exist

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:792: ProgrammingError

The above exception was the direct cause of the following exception:

client = &lt;django.test.client.Client object at 0x0000021C39359270&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C39358220&gt;

&gt;   ???

django\tests\otto\test_load_test.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\test\client.py:1124: in get
    response = super().get(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\test\client.py:475: in get
    return self.generic(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\test\client.py:671: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\test\client.py:1082: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\test\client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\corsheaders\middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\whitenoise\middleware.py:123: in __call__
    return self.get_response(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:119: in __call__
    response = self.process_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\otto\utils\middleware.py:100: in process_request
    return self.get_response(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django_structlog\middlewares\request.py:119: in __call__
    response = cast("HttpResponse", self.get_response(request))
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\utils\deprecation.py:120: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:141: in response_for_exception
    response = handle_uncaught_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\exception.py:55: in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\core\handlers\base.py:197: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\views\decorators\csrf.py:65: in _view_wrapper
    return view_func(request, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\otto\views.py:1131: in load_test
    nodes = retriever.retrieve("query string")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index_instrumentation\dispatcher.py:335: in wrapper
    result = func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\base\base_retriever.py:210: in retrieve
    nodes = self._retrieve(query_bundle)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index_instrumentation\dispatcher.py:335: in wrapper
    result = func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\retrievers\fusion_retriever.py:269: in _retrieve
    results = self._run_nested_async_queries(queries)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\retrievers\fusion_retriever.py:228: in _run_nested_async_queries
    task_results = run_async_tasks(tasks)
                   ^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\async_utils.py:96: in run_async_tasks
    outputs: List[Any] = asyncio_run(_gather())
                         ^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\async_utils.py:52: in asyncio_run
    return loop.run_until_complete(coro)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\asyncio\base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\async_utils.py:94: in _gather
    return await asyncio.gather(*tasks_to_execute)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index_instrumentation\dispatcher.py:386: in async_wrapper
    result = await func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\base\base_retriever.py:241: in aretrieve
    nodes = await self._aretrieve(query_bundle=query_bundle)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index_instrumentation\dispatcher.py:386: in async_wrapper
    result = await func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\indices\vector_store\retrievers\retriever.py:115: in _aretrieve
    return await self._aget_nodes_with_embeddings(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\core\indices\vector_store\retrievers\retriever.py:241: in _aget_nodes_with_embeddings
    query_result = await self._vector_store.aquery(query, **self._kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\vector_stores\postgres\base.py:1089: in aquery
    results = await self._async_sparse_query_with_rank(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\llama_index\vector_stores\postgres\base.py:961: in _async_sparse_query_with_rank
    res = await async_session.execute(stmt)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:463: in execute
    result = await greenlet_spawn(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\session.py:2365: in execute
    return self._execute_internal(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:580: in execute
    self._adapt_connection.await_(
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:558: in _prepare_and_execute
    self._handle_exception(error)
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:508: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;AdaptedConnection &lt;asyncpg.connection.Connection object at 0x0000021C3941F980&gt;&gt;
error = UndefinedTableError('relation "public.data_laws_lois__" does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
&gt;                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) &lt;class 'asyncpg.exceptions.UndefinedTableError'&gt;: relation "public.data_laws_lois__" does not exist
E                   [SQL: SELECT public.data_laws_lois__.id, public.data_laws_lois__.node_id, public.data_laws_lois__.text, public.data_laws_lois__.metadata_, ts_rank(public.data_laws_lois__.text_search_tsv, to_tsquery($1, $2::VARCHAR)) AS rank 
E                   FROM public.data_laws_lois__ 
E                   WHERE public.data_laws_lois__.text_search_tsv @@ to_tsquery($1, $2::VARCHAR) ORDER BY rank desc 
E                    LIMIT $3::INTEGER]
E                   [parameters: ('english', 'query|string', 100)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:792: ProgrammingError</failure></testcase><testcase classname="tests.otto.test_load_test" name="test_celery_load_tests" time="16.608" /><testcase classname="tests.otto.test_manage_users" name="test_access_manage_users" time="19.911" /><testcase classname="tests.otto.test_manage_users" name="test_modify_user" time="24.736" /><testcase classname="tests.otto.test_manage_users" name="test_get_user_form" time="14.786" /><testcase classname="tests.otto.test_manage_users" name="test_manage_users_upload" time="20.164" /><testcase classname="tests.otto.test_manage_users" name="test_manage_users_download" time="30.051" /><testcase classname="tests.otto.test_manage_users" name="test_get_cost_dashboard" time="14.155"><failure message="otto.models.CostType.DoesNotExist: CostType matching query does not exist.">client = &lt;django.test.client.Client object at 0x0000021C39343610&gt;
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C393427A0&gt;

    @pytest.mark.django_db
    def test_get_cost_dashboard(client, all_apps_user):
        user = all_apps_user()
        client.force_login(user)
        response = client.get(reverse("cost_dashboard"))
        assert response.status_code == 200
    
        # Create some costs
        bind_contextvars(user_id=user.id, feature="chat")
        for _ in range(5):
&gt;           Cost.objects.new("gemini-in", 100)

django\tests\otto\test_manage_users.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\otto\models.py:412: in new
    cost_type = CostType.objects.get(short_name=cost_type)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MultilingualQuerySet [&lt;CostType: GPT-4o Global (input)&gt;, &lt;CostType: GPT-4o Global (output)&gt;, &lt;CostType: OpenAI Embedd... (input)&gt;, &lt;CostType: o4-mini Global (output)&gt;, &lt;CostType: o3 Global (input)&gt;, '...(remaining elements truncated)...']&gt;
args = (), kwargs = {'short_name': 'gemini-in'}, clone = &lt;MultilingualQuerySet []&gt;, limit = 21, num = 0

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
&gt;           raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
E           otto.models.CostType.DoesNotExist: CostType matching query does not exist.

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:633: DoesNotExist</failure></testcase><testcase classname="tests.otto.test_manage_users" name="test_get_manage_pilots" time="15.939" /><testcase classname="tests.otto.test_manage_users" name="test_get_pilots_form" time="14.710" /><testcase classname="tests.otto.test_otto_forms" name="test_feedback_form_is_valid" time="13.970" /><testcase classname="tests.otto.test_otto_models" name="test_create_user" time="14.366" /><testcase classname="tests.otto.test_otto_models" name="test_create_security_label" time="8.736" /><testcase classname="tests.otto.test_otto_views" name="test_homepage" time="14.455" /><testcase classname="tests.otto.test_otto_views" name="test_notifications" time="14.207" /><testcase classname="tests.otto.test_otto_views" name="test_valid_feedback_form" time="14.153" /><testcase classname="tests.otto.test_otto_views" name="test_valid_feedback_form_from_message" time="14.216" /><testcase classname="tests.otto.test_otto_views" name="test_initialize_feedback_for_chat_mode" time="14.183" /><testcase classname="tests.otto.test_otto_views" name="test_manage_banner" time="14.691" /><testcase classname="tests.otto.test_secure_models.TestAccessKey" name="test_access_key_with_user" time="14.037" /><testcase classname="tests.otto.test_secure_models.TestAccessKey" name="test_access_key_with_bypass" time="9.194" /><testcase classname="tests.otto.test_secure_models.TestAccessKey" name="test_access_key_no_user_no_bypass_raises_error" time="8.742" /><testcase classname="tests.otto.test_secure_models.TestAccessKey" name="test_access_key_none_user_no_bypass_raises_error" time="8.619" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_grant_view_permission" time="15.376" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_grant_multiple_permissions" time="15.144" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_grant_empty_permissions_raises_error" time="14.717" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_grant_invalid_permission_raises_error" time="14.264" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_revoke_specific_permission" time="13.968" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_revoke_all_permissions" time="14.475" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_revoke_invalid_permission_raises_error" time="13.880" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_check_permissions_no_access_control" time="13.871" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_access_control_logging_on_create" time="13.953" /><testcase classname="tests.otto.test_secure_models.TestAccessControl" name="test_access_control_unique_constraint" time="14.379" /><testcase classname="tests.otto.test_secure_models.TestSecureManager" name="test_all_with_bypass_returns_all_objects" time="8.605" /><testcase classname="tests.otto.test_secure_models.TestSecureManager" name="test_all_with_user_filters_by_permissions" time="14.267" /><testcase classname="tests.otto.test_secure_models.TestSecureManager" name="test_get_with_permissions" time="13.898" /><testcase classname="tests.otto.test_secure_models.TestSecureManager" name="test_get_without_permissions_raises_error" time="13.900" /><testcase classname="tests.otto.test_secure_models.TestSecureManager" name="test_filter_with_permissions" time="14.101" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_create_with_bypass" time="8.776" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_create_with_user_grants_permissions" time="14.202" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_save_with_bypass" time="8.717" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_save_with_change_permission" time="13.760" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_save_without_change_permission_raises_error" time="14.597" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_delete_with_bypass" time="8.598" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_delete_with_delete_permission" time="13.839" /><testcase classname="tests.otto.test_secure_models.TestSecureModelCRUD" name="test_delete_without_delete_permission_raises_error" time="15.526" /><testcase classname="tests.otto.test_secure_models.TestEdgeCases" name="test_multiple_users_different_permissions" time="19.066" /><testcase classname="tests.otto.test_secure_models.TestEdgeCases" name="test_permission_inheritance_not_automatic" time="14.107" /><testcase classname="tests.otto.test_secure_models.TestEdgeCases" name="test_cascade_deletion_removes_access_controls" time="13.991" /><testcase classname="tests.otto.test_secure_models.TestEdgeCases" name="test_user_deletion_removes_access_controls" time="13.950" /><testcase classname="tests.otto.test_secure_models.TestEdgeCases" name="test_update_permissions_replaces_existing" time="13.649" /><testcase classname="tests.otto.test_utils_common" name="test_file_size_to_string" time="9.032" /><testcase classname="tests.otto.test_utils_common" name="test_get_app_from_path" time="9.140" /><testcase classname="tests.otto.test_utils_middleware" name="test_process_response_no_hx_request" time="8.638" /><testcase classname="tests.otto.test_utils_middleware" name="test_process_response_with_hx_request_no_messages" time="8.549" /><testcase classname="tests.otto.test_utils_middleware" name="test_process_response_with_hx_request_with_messages" time="13.775" /><testcase classname="tests.test_celery_tasks.TestExtractTextTask" name="test_extract_text_task_success" time="8.552" /><testcase classname="tests.test_celery_tasks.TestExtractTextTask" name="test_extract_text_task_file_not_found" time="8.913" /><testcase classname="tests.test_celery_tasks.TestExtractTextTask" name="test_extract_text_task_no_saved_file" time="8.902" /><testcase classname="tests.test_celery_tasks.TestExtractTextTask" name="test_extract_text_task_extraction_error" time="8.764" /><testcase classname="tests.test_celery_tasks.TestExtractTextTask" name="test_extract_text_task_with_context_vars" time="8.732" /><testcase classname="tests.test_celery_tasks.TestProcessDocumentTask" name="test_process_document_not_found" time="8.859" /><testcase classname="tests.test_celery_tasks.TestProcessDocumentTask" name="test_process_document_success" time="15.592" /><testcase classname="tests.test_celery_tasks.TestProcessDocumentTask" name="test_process_document_error_handling" time="16.662" /><testcase classname="tests.test_celery_tasks.TestProcessDocumentTask" name="test_process_document_sets_celery_task_id" time="15.664" /><testcase classname="tests.test_celery_tasks.TestProcessDocumentHelper" name="test_process_document_helper_url_success" time="15.149"><failure message="ValueError: too many values to unpack (expected 2)">self = &lt;tests.test_celery_tasks.TestProcessDocumentHelper object at 0x0000021C10D902D0&gt;
mock_create_nodes = &lt;MagicMock name='create_nodes' id='2320233429184'&gt;
mock_extract = &lt;MagicMock name='extract_markdown' id='2320236891168'&gt;
mock_fetch = &lt;MagicMock name='fetch_from_url' id='2320236890496'&gt;

    @patch('librarian.tasks.fetch_from_url')
    @patch('librarian.tasks.extract_markdown')
    @patch('librarian.tasks.create_nodes')
    def test_process_document_helper_url_success(
        self, mock_create_nodes, mock_extract, mock_fetch
    ):
        """Test processing document from URL"""
        # Create test document
        library = Library.objects.create(name="Test Library")
    
        datasource = DataSource.objects.create(name="Test Source", library=library)
    
        doc = Document.objects.create(url="https://example.com/test",
            data_source=datasource
        )
    
        # Setup mocks
        mock_fetch.return_value = b"&lt;html&gt;&lt;body&gt;Test content&lt;/body&gt;&lt;/html&gt;"
    
        mock_result = Mock()
        mock_result.markdown = "Test content"
        mock_extract.return_value = mock_result
    
        from chat.llm import OttoLLM
        llm = OttoLLM(mock_embedding=True)
    
        # Execute
&gt;       process_document_helper(doc, llm)

django\tests\test_celery_tasks.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

document = &lt;Document: https://example.com/test&gt;, llm = &lt;chat.llm.OttoLLM object at 0x0000021C38DA2150&gt;
pdf_method = 'default'

    def process_document_helper(document, llm, pdf_method="default"):
        url = document.url
        file = document.saved_file
        if not (url or file):
            raise ValueError("URL or file is required")
    
        if url:
            logger.info("Processing URL", url=url)
            base_url = (
                urllib.parse.urlparse(url).scheme
                + "://"
                + urllib.parse.urlparse(url).netloc
            )
            if current_task:
                current_task.update_state(
                    state="PROCESSING",
                    meta={
                        "status_text": _("Fetching URL..."),
                    },
                )
&gt;           content, content_type = fetch_from_url(url)
            ^^^^^^^^^^^^^^^^^^^^^
E           ValueError: too many values to unpack (expected 2)

django\librarian\tasks.py:98: ValueError</failure></testcase><testcase classname="tests.test_celery_tasks.TestTranslateFileTask" name="test_translate_file_basic" time="0.000"><skipped type="pytest.skip" message="Requires Celery context var setup (message_id). Needs refactoring to set message_id_var before task execution.">C:\otto\Otto\django\tests\test_celery_tasks.py:257: Requires Celery context var setup (message_id). Needs refactoring to set message_id_var before task execution.</skipped></testcase><testcase classname="tests.test_celery_tasks.TestTranslateFileTask" name="test_translate_file_fr_to_fr_ca" time="8.524" /><testcase classname="tests.test_celery_tasks.TestTaskTimeouts" name="test_extract_text_task_soft_time_limit" time="8.687" /><testcase classname="tests.test_celery_tasks.TestTaskTimeouts" name="test_process_document_soft_time_limit" time="8.642" /><testcase classname="tests.test_celery_tasks.TestTaskStatusTracking" name="test_document_status_lifecycle" time="13.949" /><testcase classname="tests.test_celery_tasks.TestTaskStatusTracking" name="test_document_celery_task_id_tracking" time="14.713" /><testcase classname="tests.test_celery_tasks.TestTaskCostTracking" name="test_process_document_creates_costs" time="13.854" /><testcase classname="tests.test_celery_tasks.TestTaskErrorRecovery" name="test_process_document_error_cleanup" time="15.257" /><testcase classname="tests.test_celery_tasks.TestTaskLanguageHandling" name="test_process_document_respects_language_parameter" time="15.499" /><testcase classname="tests.test_celery_tasks.TestMockEmbedding" name="test_process_document_with_mock_embedding" time="15.800" /><testcase classname="tests.test_celery_tasks.TestTaskSignatures" name="test_extract_text_task_is_shared_task" time="8.678" /><testcase classname="tests.test_celery_tasks.TestTaskSignatures" name="test_process_document_is_shared_task" time="8.611" /><testcase classname="tests.test_celery_tasks.TestTaskSignatures" name="test_translate_file_is_shared_task" time="8.627" /><testcase classname="tests.test_e2e_workflows.TestUserOnboardingWorkflow" name="test_new_user_complete_onboarding" time="13.729"><failure message="TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'">self = &lt;tests.test_e2e_workflows.TestUserOnboardingWorkflow object at 0x0000021C10D91310&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39237240&gt;

    def test_new_user_complete_onboarding(self, basic_user):
        """Test end-to-end new user onboarding workflow"""
        # Step 1: User is created (SSO authentication)
        user = basic_user(username="newuser", accept_terms=False)
        assert user.upn == "newuser.lastname@example.com"
        assert not user.accepted_terms
    
        # Step 2: User tries to access Otto (should be blocked)
        from otto.utils.decorators import permission_required
        # In real app, this would redirect to terms page
    
        # Step 3: User accepts terms
        user.accepted_terms_date = timezone.now()
        user.save()
        assert user.accepted_terms
    
        # Step 4: User is automatically added to base groups
        # (In production, this happens via SSO or admin action)
    
        # Step 5: User creates first chat
        chat = Chat.objects.create(title="My First Chat",
            user=user)
        assert chat.title == "My First Chat"
        assert chat.user == user
    
        # Step 6: User sends first message
&gt;       message = Message.objects.create(
            chat=chat,
            content="Hello, this is my first message!",
            created_by=user,
            role="user"
        )

django\tests\test_e2e_workflows.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Message: msg None: &gt;, args = ()
kwargs = {'content': 'Hello, this is my first message!', 'created_by': &lt;User: ,  (newuser@example.com)&gt;, 'role': 'user'}
cls = &lt;class 'chat.models.Message'&gt;, opts = &lt;Options for Message&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391DC940&gt;, val = 0.0
field = &lt;django.db.models.fields.FloatField: seconds_elapsed&gt;, is_related_object = False
rel_obj = &lt;Chat: Chat 500b0216-fea8-4f9e-ad2c-faa86ecec452: My First Chat&gt;
property_names = frozenset({'display_cost', 'has_sources', 'num_files', 'pk', 'sorted_files', 'sources'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestUserOnboardingWorkflow" name="test_admin_user_onboarding" time="19.295" /><testcase classname="tests.test_e2e_workflows.TestChatConversationWorkflow" name="test_complete_chat_conversation" time="13.757"><failure message="TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'">self = &lt;tests.test_e2e_workflows.TestChatConversationWorkflow object at 0x0000021C10D916D0&gt;
mock_genai = &lt;MagicMock name='GenerativeModel' id='2320233429184'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3922C9A0&gt;

    @patch('chat.llm.genai.GenerativeModel')
    def test_complete_chat_conversation(self, mock_genai, basic_user):
        """Test end-to-end chat conversation workflow"""
        user = basic_user()
    
        # Mock LLM responses
        mock_responses = [
            Mock(text="Hello! How can I help you today?"),
            Mock(text="Sure, I can help with that."),
            Mock(text="Here's the answer to your question.")
        ]
        mock_genai.return_value.generate_content.side_effect = mock_responses
    
        # Step 1: User creates new chat
        chat = Chat.objects.create(title="Technical Discussion",
            user=user)
        assert chat.title == "Technical Discussion"
    
        # Step 2: User sends first message
&gt;       user_msg1 = Message.objects.create(
            chat=chat,
            content="Hello, I need help with Python",
            created_by=user,
            role="user"
        )

django\tests\test_e2e_workflows.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Message: msg None: &gt;, args = ()
kwargs = {'content': 'Hello, I need help with Python', 'created_by': &lt;User: ,  (basic_user@example.com)&gt;, 'role': 'user'}
cls = &lt;class 'chat.models.Message'&gt;, opts = &lt;Options for Message&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391DDA50&gt;, val = 0.0
field = &lt;django.db.models.fields.FloatField: seconds_elapsed&gt;, is_related_object = False
rel_obj = &lt;Chat: Chat 105a6005-9b10-42de-bfa8-a492fe3381a3: Technical Discussion&gt;
property_names = frozenset({'display_cost', 'has_sources', 'num_files', 'pk', 'sorted_files', 'sources'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestDocumentRAGWorkflow" name="test_complete_document_rag_workflow" time="18.847"><failure message="TypeError: DataSource() got unexpected keyword arguments: 'created_by'">self = &lt;tests.test_e2e_workflows.TestDocumentRAGWorkflow object at 0x0000021C10D91810&gt;
mock_genai = &lt;MagicMock name='GenerativeModel' id='2320236891840'&gt;
mock_extract = &lt;MagicMock name='extract_markdown' id='2320236893520'&gt;
mock_fetch = &lt;MagicMock name='fetch_from_url' id='2320236895872'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C391907C0&gt;

    @patch('librarian.utils.process_engine.fetch_from_url')
    @patch('librarian.utils.process_engine.extract_markdown')
    @patch('chat.llm.genai.GenerativeModel')
    def test_complete_document_rag_workflow(
        self, mock_genai, mock_extract, mock_fetch, basic_user
    ):
        """Test end-to-end document upload to RAG query workflow"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        # Mock document extraction
        mock_fetch.return_value = b"&lt;html&gt;&lt;body&gt;Important document content&lt;/body&gt;&lt;/html&gt;"
        mock_result = Mock()
        mock_result.markdown = "# Important Document\n\nThis is important information."
        mock_extract.return_value = mock_result
    
        # Mock LLM response
        mock_genai.return_value.generate_content.return_value = Mock(
            text="Based on the document, here's the answer..."
        )
    
        # Step 1: User creates private library
        library = Library.objects.create(name="My Research Library",
            is_public=False,
            created_by=user
        )
        assert library.name == "My Research Library"
    
        # Step 2: User creates datasource in library
&gt;       datasource = DataSource.objects.create(library=library,
            name="Research Papers",
            created_by=user
        )

django\tests\test_e2e_workflows.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\models.py:266: in create
    return super().create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\manager.py:412: in create
    return super().create(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\translator.py:330: in new_init
    old_init(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;DataSource: Research Papers&gt;, args = (), kwargs = {'created_by': &lt;User: ,  (basic_user@example.com)&gt;}
cls = &lt;class 'librarian.models.DataSource'&gt;, opts = &lt;Options for DataSource&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391A90F0&gt;, val = None
field = &lt;django.db.models.fields.related.OneToOneField: chat&gt;, is_related_object = False
rel_obj = &lt;Library: My Research Library&gt;, property_names = frozenset({'label', 'pk', 'short_label'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DataSource() got unexpected keyword arguments: 'created_by'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestLibraryManagementWorkflow" name="test_library_collaboration_workflow" time="29.578"><failure message="TypeError: DataSource() got unexpected keyword arguments: 'created_by'">self = &lt;tests.test_e2e_workflows.TestLibraryManagementWorkflow object at 0x0000021C10D91950&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3915F880&gt;

    def test_library_collaboration_workflow(self, basic_user):
        """Test end-to-end library collaboration workflow"""
        owner = basic_user(username="owner")
        contributor = basic_user(username="contributor")
        viewer = basic_user(username="viewer")
    
        owner_key = AccessKey(user=owner)
    
        # Step 1: Owner creates library
        library = Library.objects.create(
            name="Team Library",
            is_public=False,
            created_by=owner
        )
    
        # Step 2: Owner adds contributors
        LibraryUserRole.objects.create(
            user=contributor,
            library=library,
            role="contributor"
        )
    
        LibraryUserRole.objects.create(
            user=viewer,
            library=library,
            role="viewer"
        )
    
        # Step 3: Owner creates datasource
&gt;       datasource = DataSource.objects.create(
            library=library,
            name="Shared Documents",
            created_by=owner
        )

django\tests\test_e2e_workflows.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\models.py:266: in create
    return super().create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\manager.py:412: in create
    return super().create(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\translator.py:330: in new_init
    old_init(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;DataSource: Shared Documents&gt;, args = (), kwargs = {'created_by': &lt;User: ,  (owner@example.com)&gt;}
cls = &lt;class 'librarian.models.DataSource'&gt;, opts = &lt;Options for DataSource&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C39194370&gt;, val = None
field = &lt;django.db.models.fields.related.OneToOneField: chat&gt;, is_related_object = False, rel_obj = &lt;Library: Team Library&gt;
property_names = frozenset({'label', 'pk', 'short_label'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DataSource() got unexpected keyword arguments: 'created_by'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestLibraryManagementWorkflow" name="test_library_visibility_workflow" time="24.207" /><testcase classname="tests.test_e2e_workflows.TestPresetSharingWorkflow" name="test_preset_creation_and_sharing" time="18.836"><failure message="TypeError: ChatOptions() got unexpected keyword arguments: 'model_id'">self = &lt;tests.test_e2e_workflows.TestPresetSharingWorkflow object at 0x0000021C10D91BD0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C391913A0&gt;

    def test_preset_creation_and_sharing(self, basic_user):
        """Test end-to-end preset creation and sharing"""
        creator = basic_user(username="creator")
        recipient = basic_user(username="recipient")
    
        # Step 1: Creator creates custom preset
&gt;       options = ChatOptions.objects.create(
            mode="qa",
            model_id="gemini-1.5-pro"
        )

django\tests\test_e2e_workflows.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;ChatOptions: ChatOptions object (None)&gt;, args = (), kwargs = {'model_id': 'gemini-1.5-pro'}
cls = &lt;class 'chat.models.ChatOptions'&gt;, opts = &lt;Options for ChatOptions&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391B3F10&gt;, val = False
field = &lt;django.db.models.fields.BooleanField: qa_rewrite&gt;, is_related_object = False
property_names = frozenset({'pk', 'qa_prompt_combined'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: ChatOptions() got unexpected keyword arguments: 'model_id'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestCostBudgetWorkflow" name="test_cost_tracking_workflow" time="14.373"><failure message="TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'">self = &lt;tests.test_e2e_workflows.TestCostBudgetWorkflow object at 0x0000021C10D91D10&gt;
mock_genai = &lt;MagicMock name='GenerativeModel' id='2320233429184'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39223880&gt;

    @patch('chat.llm.genai.GenerativeModel')
    def test_cost_tracking_workflow(self, mock_genai, basic_user):
        """Test end-to-end cost tracking workflow"""
        user = basic_user()
    
        mock_genai.return_value.generate_content.return_value = Mock(
            text="Response text"
        )
    
        # Step 1: User starts with zero costs
        initial_cost = Cost.objects.get_user_cost_this_month(user)
        assert initial_cost == 0
    
        # Step 2: User creates chat
        chat = Chat.objects.create(title="Cost Test Chat",
            user=user)
    
        # Step 3: User sends messages, incurring costs
        for i in range(5):
&gt;           Message.objects.create(
                chat=chat,
                content=f"Message {i}",
                created_by=user,
                role="user"
            )

django\tests\test_e2e_workflows.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Message: msg None: &gt;, args = ()
kwargs = {'content': 'Message 0', 'created_by': &lt;User: ,  (basic_user@example.com)&gt;, 'role': 'user'}
cls = &lt;class 'chat.models.Message'&gt;, opts = &lt;Options for Message&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391DD630&gt;, val = 0.0
field = &lt;django.db.models.fields.FloatField: seconds_elapsed&gt;, is_related_object = False
rel_obj = &lt;Chat: Chat bbb58b8d-c9a1-42fd-a510-95467c52ced6: Cost Test Chat&gt;
property_names = frozenset({'display_cost', 'has_sources', 'num_files', 'pk', 'sorted_files', 'sources'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestCostBudgetWorkflow" name="test_budget_limit_workflow" time="13.708" /><testcase classname="tests.test_e2e_workflows.TestFileUploadWorkflow" name="test_chat_file_upload_workflow" time="13.663"><failure message="TypeError: ChatFile() got unexpected keyword arguments: 'chat', 'created_by'">self = &lt;tests.test_e2e_workflows.TestFileUploadWorkflow object at 0x0000021C10D91F90&gt;
mock_extract = &lt;MagicMock name='extract_markdown' id='2319963351968'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39231E40&gt;

    @patch('librarian.utils.process_engine.extract_markdown')
    def test_chat_file_upload_workflow(self, mock_extract, basic_user):
        """Test end-to-end file upload in chat"""
        user = basic_user()
    
        # Mock file extraction
        mock_result = Mock()
        mock_result.markdown = "Extracted file content"
        mock_extract.return_value = mock_result
    
        # Step 1: User creates chat
        chat = Chat.objects.create(title="File Discussion",
            user=user)
    
        # Step 2: User uploads file
&gt;       chat_file = ChatFile.objects.create(
            filename="document.pdf",
            content_type="application/pdf",
            chat=chat,
            created_by=user
        )

django\tests\test_e2e_workflows.py:543: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\chat\models.py:691: in create
    return super().create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;ChatFile: File None: document.pdf&gt;, args = ()
kwargs = {'chat': &lt;Chat: Chat 0449321b-59b6-4330-b94f-bee73cfe006e: File Discussion&gt;, 'created_by': &lt;User: ,  (basic_user@example.com)&gt;}
cls = &lt;class 'chat.models.ChatFile'&gt;, opts = &lt;Options for ChatFile&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C3923AA70&gt;, val = ''
field = &lt;django.db.models.fields.TextField: text&gt;, is_related_object = False, rel_obj = &lt;SavedFile: &gt;
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: ChatFile() got unexpected keyword arguments: 'chat', 'created_by'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestErrorRecoveryWorkflows" name="test_document_processing_error_recovery" time="19.125"><failure message="TypeError: DataSource() got unexpected keyword arguments: 'created_by'">self = &lt;tests.test_e2e_workflows.TestErrorRecoveryWorkflows object at 0x0000021C10D920D0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39213060&gt;

    def test_document_processing_error_recovery(self, basic_user):
        """Test document processing error and retry workflow"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Error Test Library",
            created_by=user
        )
    
&gt;       datasource = DataSource.objects.create(library=library,
            name="Error Test Source",
            created_by=user
        )

django\tests\test_e2e_workflows.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\models.py:266: in create
    return super().create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\manager.py:412: in create
    return super().create(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\translator.py:330: in new_init
    old_init(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;DataSource: Error Test Source&gt;, args = (), kwargs = {'created_by': &lt;User: ,  (basic_user@example.com)&gt;}
cls = &lt;class 'librarian.models.DataSource'&gt;, opts = &lt;Options for DataSource&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C391B19C0&gt;, val = None
field = &lt;django.db.models.fields.related.OneToOneField: chat&gt;, is_related_object = False
rel_obj = &lt;Library: Error Test Library&gt;, property_names = frozenset({'label', 'pk', 'short_label'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DataSource() got unexpected keyword arguments: 'created_by'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestErrorRecoveryWorkflows" name="test_llm_error_recovery_workflow" time="16.955" /><testcase classname="tests.test_e2e_workflows.TestMultiUserCollaboration" name="test_team_library_workflow" time="29.510"><failure message="TypeError: DataSource() got unexpected keyword arguments: 'created_by'">self = &lt;tests.test_e2e_workflows.TestMultiUserCollaboration object at 0x0000021C10D92350&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3915DD00&gt;

    def test_team_library_workflow(self, basic_user):
        """Test team collaboration on shared library"""
        team_lead = basic_user(username="lead")
        member1 = basic_user(username="member1")
        member2 = basic_user(username="member2")
    
        lead_key = AccessKey(user=team_lead)
    
        # Step 1: Team lead creates shared library
        library = Library.objects.create(
            name="Team Project Library",
            is_public=False,
            created_by=team_lead
        )
    
        # Step 2: Add team members as contributors
        LibraryUserRole.objects.create(
            user=member1,
            library=library,
            role="contributor"
        )
    
        LibraryUserRole.objects.create(
            user=member2,
            library=library,
            role="contributor"
        )
    
        # Step 3: Create shared datasource
&gt;       datasource = DataSource.objects.create(
            library=library,
            name="Project Documents",
            created_by=team_lead
        )

django\tests\test_e2e_workflows.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
django\librarian\models.py:266: in create
    return super().create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\manager.py:412: in create
    return super().create(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\translator.py:330: in new_init
    old_init(self, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;DataSource: Project Documents&gt;, args = (), kwargs = {'created_by': &lt;User: ,  (lead@example.com)&gt;}
cls = &lt;class 'librarian.models.DataSource'&gt;, opts = &lt;Options for DataSource&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C39196830&gt;, val = None
field = &lt;django.db.models.fields.related.OneToOneField: chat&gt;, is_related_object = False
rel_obj = &lt;Library: Team Project Library&gt;, property_names = frozenset({'label', 'pk', 'short_label'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: DataSource() got unexpected keyword arguments: 'created_by'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_e2e_workflows.TestFeedbackWorkflow" name="test_feedback_submission_workflow" time="19.434" /><testcase classname="tests.test_e2e_workflows.TestSessionManagementWorkflow" name="test_user_session_continuity" time="14.440"><failure message="TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'">self = &lt;tests.test_e2e_workflows.TestSessionManagementWorkflow object at 0x0000021C10D925D0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39212CA0&gt;

    def test_user_session_continuity(self, basic_user):
        """Test session continuity across multiple actions"""
        user = basic_user()
    
        # Simulate user session with multiple actions
        # Step 1: User logs in (SSO handled externally)
    
        # Step 2: User creates multiple chats
        chats = []
        for i in range(3):
            chat = Chat.objects.create(title=f"Session Chat {i}",
                user=user)
            chats.append(chat)
    
        # Step 3: User creates messages across chats
        for chat in chats:
&gt;           Message.objects.create(
                chat=chat,
                content="Session message",
                created_by=user,
                role="user"
            )

django\tests\test_e2e_workflows.py:775: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Message: msg None: &gt;, args = ()
kwargs = {'content': 'Session message', 'created_by': &lt;User: ,  (basic_user@example.com)&gt;, 'role': 'user'}
cls = &lt;class 'chat.models.Message'&gt;, opts = &lt;Options for Message&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C39239F90&gt;, val = 0.0
field = &lt;django.db.models.fields.FloatField: seconds_elapsed&gt;, is_related_object = False
rel_obj = &lt;Chat: Chat efbe6923-c994-4e7c-bd06-e3821b8132a3: Session Chat 0&gt;
property_names = frozenset({'display_cost', 'has_sources', 'num_files', 'pk', 'sorted_files', 'sources'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Message() got unexpected keyword arguments: 'content', 'created_by', 'role'

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:569: TypeError</failure></testcase><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_feedback_form_missing_required_fields" time="13.836" /><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_feedback_form_user_mismatch" time="19.229" /><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_library_form_missing_name" time="14.307" /><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_datasource_form_invalid_library" time="14.112" /><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_document_url_form_invalid_url" time="18.992" /><testcase classname="tests.test_negative_cases.TestFormValidationFailures" name="test_preset_form_invalid_model_id" time="13.886" /><testcase classname="tests.test_negative_cases.TestInputValidation" name="test_sql_injection_in_search" time="13.732" /><testcase classname="tests.test_negative_cases.TestInputValidation" name="test_xss_in_feedback_message" time="14.230" /><testcase classname="tests.test_negative_cases.TestInputValidation" name="test_extremely_long_input" time="14.023" /><testcase classname="tests.test_negative_cases.TestInputValidation" name="test_unicode_and_special_characters" time="23.284" /><testcase classname="tests.test_negative_cases.TestInputValidation" name="test_null_byte_injection" time="16.653" /><testcase classname="tests.test_negative_cases.TestPermissionDenied" name="test_non_admin_cannot_manage_users" time="14.356" /><testcase classname="tests.test_negative_cases.TestPermissionDenied" name="test_non_admin_cannot_load_laws" time="15.814" /><testcase classname="tests.test_negative_cases.TestPermissionDenied" name="test_user_cannot_access_other_user_chat" time="19.848" /><testcase classname="tests.test_negative_cases.TestPermissionDenied" name="test_user_cannot_edit_other_user_preset" time="19.641" /><testcase classname="tests.test_negative_cases.TestPermissionDenied" name="test_contributor_cannot_delete_library" time="25.689" /><testcase classname="tests.test_negative_cases.TestHTTPErrorResponses" name="test_404_nonexistent_chat" time="15.691" /><testcase classname="tests.test_negative_cases.TestHTTPErrorResponses" name="test_404_nonexistent_library" time="15.076" /><testcase classname="tests.test_negative_cases.TestHTTPErrorResponses" name="test_404_nonexistent_document" time="14.742" /><testcase classname="tests.test_negative_cases.TestHTTPErrorResponses" name="test_invalid_uuid_format" time="8.963" /><testcase classname="tests.test_negative_cases.TestFileUploadValidation" name="test_document_without_file_or_url" time="19.871" /><testcase classname="tests.test_negative_cases.TestFileUploadValidation" name="test_blocked_url_validation" time="14.361" /><testcase classname="tests.test_negative_cases.TestFileUploadValidation" name="test_file_size_limits" time="14.380"><failure message="AssertionError: assert False&#10; +  where False = has_perm('chat.upload_large_files')&#10; +    where has_perm = &lt;User: ,  (basic_user@example.com)&gt;.has_perm">self = &lt;tests.test_negative_cases.TestFileUploadValidation object at 0x0000021C10E9EC40&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C39D66AC0&gt;

    def test_file_size_limits(self, basic_user):
        """Test file size validation"""
        user = basic_user()
    
        # Regular users should have file size limits
        # Admins and data stewards can upload large files
        assert not user.has_perm('chat.upload_large_files')
    
        # Make user admin
        user.make_otto_admin()
        user.refresh_from_db()  # Refresh to get updated group membership
    
&gt;       assert user.has_perm('chat.upload_large_files')
E       AssertionError: assert False
E        +  where False = has_perm('chat.upload_large_files')
E        +    where has_perm = &lt;User: ,  (basic_user@example.com)&gt;.has_perm

django\tests\test_negative_cases.py:372: AssertionError</failure></testcase><testcase classname="tests.test_negative_cases.TestDataIntegrity" name="test_duplicate_upn_rejected" time="14.556" /><testcase classname="tests.test_negative_cases.TestDataIntegrity" name="test_library_without_name" time="14.110" /><testcase classname="tests.test_negative_cases.TestDataIntegrity" name="test_datasource_requires_library" time="14.189" /><testcase classname="tests.test_negative_cases.TestDataIntegrity" name="test_negative_budget_value" time="14.464" /><testcase classname="tests.test_negative_cases.TestEdgeCases" name="test_zero_cost_calculation" time="14.755" /><testcase classname="tests.test_negative_cases.TestEdgeCases" name="test_empty_string_inputs" time="15.484" /><testcase classname="tests.test_negative_cases.TestEdgeCases" name="test_whitespace_only_inputs" time="14.861" /><testcase classname="tests.test_negative_cases.TestEdgeCases" name="test_date_boundary_conditions" time="13.898" /><testcase classname="tests.test_negative_cases.TestConcurrentAccess" name="test_simultaneous_library_edit" time="19.686" /><testcase classname="tests.test_negative_cases.TestConcurrentAccess" name="test_race_condition_user_creation" time="14.077" /><testcase classname="tests.test_negative_cases.TestMalformedData" name="test_malformed_json_in_chat_options" time="14.184" /><testcase classname="tests.test_negative_cases.TestMalformedData" name="test_invalid_enum_values" time="13.966" /><testcase classname="tests.test_negative_cases.TestMalformedData" name="test_invalid_foreign_key_reference" time="14.364" /><testcase classname="tests.test_negative_cases.TestMalformedData" name="test_circular_reference_prevention" time="19.428" /><testcase classname="tests.test_negative_cases.TestInternationalization" name="test_missing_french_translation" time="19.557" /><testcase classname="tests.test_negative_cases.TestInternationalization" name="test_mixed_language_content" time="19.437" /><testcase classname="tests.test_negative_cases.TestStateManagement" name="test_feedback_status_transitions" time="14.959" /><testcase classname="tests.test_negative_cases.TestStateManagement" name="test_document_status_lifecycle" time="19.244" /><testcase classname="tests.test_performance.TestLLMPerformance" name="test_ottollm_initialization_performance" time="10.763"><failure message="AssertionError: OttoLLM initialization took 1.793s, expected &lt; 1.0s&#10;assert 1.7927350999962073 &lt; 1.0&#10; +  where 1.7927350999962073 = &lt;tests.test_performance.PerformanceBenchmark object at 0x0000021C38E55550&gt;.elapsed_time">self = &lt;tests.test_performance.TestLLMPerformance object at 0x0000021C10FA87D0&gt;

    def test_ottollm_initialization_performance(self):
        """Test LLM initialization time"""
        with PerformanceBenchmark("OttoLLM initialization") as bench:
            llm = OttoLLM(mock_embedding=True)
    
        # Initialization should be fast (&lt; 1 second)
&gt;       bench.assert_performance(max_time=1.0)

django\tests\test_performance.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tests.test_performance.PerformanceBenchmark object at 0x0000021C38E55550&gt;, max_time = 1.0, max_queries = None

    def assert_performance(self, max_time=None, max_queries=None):
        """Assert performance meets requirements"""
        if max_time and self.elapsed_time:
&gt;           assert self.elapsed_time &lt; max_time, \
                f"{self.name} took {self.elapsed_time:.3f}s, expected &lt; {max_time}s"
E           AssertionError: OttoLLM initialization took 1.793s, expected &lt; 1.0s
E           assert 1.7927350999962073 &lt; 1.0
E            +  where 1.7927350999962073 = &lt;tests.test_performance.PerformanceBenchmark object at 0x0000021C38E55550&gt;.elapsed_time

django\tests\test_performance.py:72: AssertionError</failure></testcase><testcase classname="tests.test_performance.TestLLMPerformance" name="test_simple_chat_response_time" time="15.754" /><testcase classname="tests.test_performance.TestLLMPerformance" name="test_concurrent_llm_requests" time="15.005"><failure message="ValueError: The following fields do not exist in this model: options">self = &lt;tests.test_performance.TestLLMPerformance object at 0x0000021C10E9F5C0&gt;
mock_genai = &lt;MagicMock name='GenerativeModel' id='2320236894864'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397D74C0&gt;

    @patch('chat.llm.genai.GenerativeModel')
    def test_concurrent_llm_requests(self, mock_genai, basic_user):
        """Test LLM throughput with concurrent requests"""
        user = basic_user()
    
        mock_response = Mock()
        mock_response.text = "Concurrent response"
        mock_genai.return_value.generate_content.return_value = mock_response
    
        def create_chat_and_respond():
            """Create a chat and get a response"""
            chat = Chat.objects.create(
                title=f"Concurrent Test {threading.get_ident()}",
                user=user,
                options=ChatOptions.objects.create(mode="chat")
            )
    
            Message.objects.create(chat=chat,
                text="Test message", is_bot=False
            )
    
            llm = OttoLLM(mock_embedding=True)
            return True
    
        # Test with 10 concurrent requests
        with PerformanceBenchmark("10 concurrent LLM requests") as bench:
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = [executor.submit(create_chat_and_respond) for _ in range(10)]
&gt;               results = [f.result() for f in as_completed(futures)]
                           ^^^^^^^^^^

django\tests\test_performance.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\tests\test_performance.py:132: in create_chat_and_respond
    chat = Chat.objects.create(
django\chat\models.py:93: in create
    instance = super().create(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;QuerySet [&lt;Chat: Chat e9f73ba5-0c1c-4637-a7e9-545c4e77678e: &gt;, &lt;Chat: Chat 96cbe58d-2d44-4418-80b4-ec3cb8a97609: &gt;, &lt;Chat: Chat 3923d843-7c0f-4f4f-959e-267a3fde7c84: &gt;, &lt;Chat: Chat 1a7adc9d-c569-43de-8d96-2fd3baeae7ff: &gt;]&gt;
kwargs = {'loaded_preset': None, 'options': &lt;ChatOptions: ChatOptions object (8496)&gt;, 'title': 'Concurrent Test 28012', 'user': &lt;User: ,  (basic_user@example.com)&gt;}
reverse_one_to_one_fields = frozenset({'options'})

    def create(self, **kwargs):
        """
        Create a new object with the given kwargs, saving it to the database
        and returning the created object.
        """
        reverse_one_to_one_fields = frozenset(kwargs).intersection(
            self.model._meta._reverse_one_to_one_field_names
        )
        if reverse_one_to_one_fields:
&gt;           raise ValueError(
                "The following fields do not exist in this model: %s"
                % ", ".join(reverse_one_to_one_fields)
            )
E           ValueError: The following fields do not exist in this model: options

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:656: ValueError</failure></testcase><testcase classname="tests.test_performance.TestDocumentProcessingPerformance" name="test_document_creation_performance" time="20.475"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestDocumentProcessingPerformance object at 0x0000021C10FA8A50&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397D6700&gt;

    def test_document_creation_performance(self, basic_user):
        """Test document creation without processing"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Performance Test Library")
    
        datasource = DataSource.objects.create(library=library,
            name="Performance Test Source")
    
        with PerformanceBenchmark("Create 100 documents") as bench:
            documents = []
            for i in range(100):
&gt;               doc = Document.objects.create(data_source=datasource,
                    url=f"https://example.com/doc{i}",
                    title=f"Document {i}")

django\tests\test_performance.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: https://example.com/doc0&gt;, args = (), kwargs = {'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C39153250&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Performance Test Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestDocumentProcessingPerformance" name="test_batch_document_processing" time="19.991"><failure message="TypeError: Model.save() got an unexpected keyword argument 'access_key'">self = &lt;tests.test_performance.TestDocumentProcessingPerformance object at 0x0000021C10FA8B90&gt;
mock_extract = &lt;MagicMock name='extract_markdown' id='2320236894528'&gt;
mock_fetch = &lt;MagicMock name='fetch_from_url' id='2320236889152'&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397D1080&gt;

    @patch('librarian.utils.process_engine.fetch_from_url')
    @patch('librarian.utils.process_engine.extract_markdown')
    def test_batch_document_processing(self, mock_extract, mock_fetch, basic_user):
        """Test processing multiple documents"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Batch Test Library")
    
        datasource = DataSource.objects.create(library=library,
            name="Batch Test Source")
    
        # Mock document content
        mock_fetch.return_value = b"&lt;html&gt;&lt;body&gt;Test content&lt;/body&gt;&lt;/html&gt;"
        mock_result = Mock()
        mock_result.markdown = "Test content"
        mock_extract.return_value = mock_result
    
        # Create 10 documents
        documents = []
        for i in range(10):
            doc = Document.objects.create(data_source=datasource,
                url=f"https://example.com/doc{i}")
            documents.append(doc)
    
        with PerformanceBenchmark("Process 10 documents") as bench:
            for doc in documents:
                # Simulate processing (actual processing would be in Celery task)
                doc.text = "Processed content"
                doc.status = "COMPLETE"
&gt;               doc.save(access_key=access_key)
E               TypeError: Model.save() got an unexpected keyword argument 'access_key'

django\tests\test_performance.py:214: TypeError</failure></testcase><testcase classname="tests.test_performance.TestVectorStorePerformance" name="test_vector_store_initialization" time="10.358" /><testcase classname="tests.test_performance.TestVectorStorePerformance" name="test_similarity_search_performance" time="0.000"><skipped type="pytest.skip" message="query_engine API no longer exists in OttoLLM - needs refactoring to use current API">C:\otto\Otto\django\tests\test_performance.py:235: query_engine API no longer exists in OttoLLM - needs refactoring to use current API</skipped></testcase><testcase classname="tests.test_performance.TestSecureModelQueryPerformance" name="test_secure_query_performance" time="19.965"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestSecureModelQueryPerformance object at 0x0000021C10FA8F50&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397C74C0&gt;

    def test_secure_query_performance(self, basic_user):
        """Test SecureModel query performance"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        # Create test data
        library = Library.objects.create(name="Query Performance Test")
    
        datasource = DataSource.objects.create(library=library,
            name="Query Performance Source")
    
        # Create 50 documents
        for i in range(50):
&gt;           Document.objects.create(data_source=datasource,
                title=f"Document {i}")

django\tests\test_performance.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = (), kwargs = {'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C3976FEE0&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Query Performance Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestSecureModelQueryPerformance" name="test_secure_query_with_filters" time="19.388"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestSecureModelQueryPerformance object at 0x0000021C10FA9090&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397A6C00&gt;

    def test_secure_query_with_filters(self, basic_user):
        """Test SecureModel filtered query performance"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Filter Test Library")
    
        datasource = DataSource.objects.create(library=library,
            name="Filter Test Source")
    
        # Create documents with different statuses
        for i in range(100):
            status = "COMPLETE" if i % 2 == 0 else "PENDING"
&gt;           Document.objects.create(data_source=datasource,
                title=f"Document {i}",
                status=status)

django\tests\test_performance.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = (), kwargs = {'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C3976FBE0&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Filter Test Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestSecureModelQueryPerformance" name="test_n_plus_one_query_prevention" time="19.671"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestSecureModelQueryPerformance object at 0x0000021C10E9FA80&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397D20C0&gt;

    def test_n_plus_one_query_prevention(self, basic_user):
        """Test that N+1 query problem is avoided"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="N+1 Test Library")
    
        datasource = DataSource.objects.create(library=library,
            name="N+1 Test Source")
    
        # Create 20 documents
        for i in range(20):
&gt;           Document.objects.create(data_source=datasource,
                title=f"Document {i}")

django\tests\test_performance.py:321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = (), kwargs = {'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C397DA590&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: N+1 Test Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestMemoryAndResources" name="test_large_query_result_memory" time="19.876"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestMemoryAndResources object at 0x0000021C10FA9450&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C397D2980&gt;

    def test_large_query_result_memory(self, basic_user):
        """Test memory usage with large query results"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Memory Test Library")
    
        datasource = DataSource.objects.create(library=library,
            name="Memory Test Source")
    
        # Create 200 documents with text content
        for i in range(200):
&gt;           Document.objects.create(data_source=datasource,
                title=f"Document {i}",
                text="A" * 1000,  # 1KB of text per document
                created_by=user
            )

django\tests\test_performance.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = ()
kwargs = {'created_by': &lt;User: ,  (basic_user@example.com)&gt;, 'text': 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C397DA9B0&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Memory Test Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestMemoryAndResources" name="test_cache_effectiveness" time="14.366" /><testcase classname="tests.test_performance.TestStressScenarios" name="test_high_volume_chat_creation" time="24.019" /><testcase classname="tests.test_performance.TestStressScenarios" name="test_rapid_permission_checks" time="22.392" /><testcase classname="tests.test_performance.TestCostTrackingPerformance" name="test_cost_aggregation_performance" time="14.695" /><testcase classname="tests.test_performance.TestRateLimitingPerformance" name="test_rate_limit_handling" time="16.967" /><testcase classname="tests.test_performance.TestPerformanceRegression" name="test_secure_model_query_baseline" time="19.427"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestPerformanceRegression object at 0x0000021C10FA9D10&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3979B920&gt;

    def test_secure_model_query_baseline(self, basic_user):
        """Baseline performance test for SecureModel queries"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        # Create baseline data
        library = Library.objects.create(name="Baseline Test")
    
        datasource = DataSource.objects.create(library=library,
            name="Baseline Source")
    
        for i in range(50):
&gt;           Document.objects.create(data_source=datasource,
                title=f"Document {i}")

django\tests\test_performance.py:665: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = (), kwargs = {'title': 'Document 0'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C3AFE0EB0&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Baseline Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.text_extractor.test_tasks" name="test_process_ocr_document_image" time="14.768" /><testcase classname="tests.text_extractor.test_tasks" name="test_process_ocr_document_pdf" time="14.451"><failure message="AssertionError: assert 'RIF drawing' == 'Page 1\nPage 2\nPage 3'&#10;  &#10;  #x1B[0m#x1B[92m+ RIF drawing#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[91m- Page 1#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[91m- Page 2#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[91m- Page 3#x1B[39;49;00m#x1B[90m#x1B[39;49;00m">mock_pdf_file3 = ('temp_file1.pdf', b'%PDF-1.3\n%\x93\x8c\x8b\x9e ReportLab Generated PDF document http://www.reportlab.com\n1 0 obj\n&lt;...PDF document -- digest (http://www.reportlab.com)\n\n/Info 7 0 R\n/Root 6 0 R\n/Size 12\n&gt;&gt;\nstartxref\n1808\n%%EOF\n')
all_apps_user = &lt;function all_apps_user.&lt;locals&gt;.new_user at 0x0000021C3AFB8B80&gt;

    @pytest.mark.django_db
    def test_process_ocr_document_pdf(mock_pdf_file3, all_apps_user):
        file_name, file_content = mock_pdf_file3
    
        # Create an OutputFile to save results to
        from otto.secure_models import AccessKey
        from text_extractor.models import OutputFile, UserRequest
    
        user = all_apps_user()
        access_key = AccessKey(user=user)
        UserRequest.grant_create_to(access_key)
        OutputFile.grant_create_to(access_key)
    
        user_request = UserRequest.objects.create(access_key=access_key, name="test")
        output_file = OutputFile.objects.create(
            access_key=access_key, user_request=user_request, file_name="test_pdf"
        )
    
        current_task_mock = mock.MagicMock()
        current_task_mock.update_state = mock.MagicMock()
    
        mock_create_searchable_pdf = mock.MagicMock(return_value={
            "error": False,
            "pdf_content": [b"mock pdf content"],
            "all_text": "RIF drawing",
            "cost": Decimal("0.01")
        })
    
        with (
            mock.patch("text_extractor.tasks.current_task", current_task_mock),
            mock.patch("text_extractor.tasks.create_searchable_pdf", mock_create_searchable_pdf),
        ):
            result = process_ocr_document(
                file_content, file_name, str(output_file.id), str(user.id)
            )
    
            current_task_mock.update_state.assert_called_once_with(state="PROCESSING")
    
            assert type(result["cost"]) == Decimal
            assert result["cost"] &gt;= 0
            assert result["input_name"] == "temp_file1"
            assert result["error"] is False
    
            # Check that files were saved to the database
            output_file.refresh_from_db()
            assert output_file.pdf_file is not None
            assert output_file.txt_file is not None
            assert output_file.celery_task_ids == []
    
            # Check file contents
            with output_file.txt_file.open("r") as f:
&gt;               assert f.read() == "Page 1\nPage 2\nPage 3"
E               AssertionError: assert 'RIF drawing' == 'Page 1\nPage 2\nPage 3'
E                 
E                 #x1B[0m#x1B[92m+ RIF drawing#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E                 #x1B[91m- Page 1#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E                 #x1B[91m- Page 2#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E                 #x1B[91m- Page 3#x1B[39;49;00m#x1B[90m#x1B[39;49;00m

django\tests\text_extractor\test_tasks.py:119: AssertionError</failure></testcase><testcase classname="tests.text_extractor.test_utils" name="test_format_merged_file_name" time="9.665" /><testcase classname="tests.text_extractor.test_utils" name="test_resize_image_to_a4" time="8.825" /><testcase classname="tests.text_extractor.test_utils" name="test_dist" time="8.695" /><testcase classname="tests.text_extractor.test_utils" name="test_get_page_count_pdf" time="8.940" /><testcase classname="tests.text_extractor.test_utils" name="test_get_page_count_image" time="9.083" /><testcase classname="tests.text_extractor.test_utils" name="test_get_page_count_unsupported" time="8.791" /><testcase classname="tests.text_extractor.test_utils" name="test_calculate_start_pages_empty" time="9.082" /><testcase classname="tests.text_extractor.test_utils" name="test_calculate_start_pages_single_file" time="9.120" /><testcase classname="tests.text_extractor.test_utils" name="test_calculate_start_pages_multiple_files" time="8.839" /><testcase classname="tests.text_extractor.test_views" name="test_index_view" time="14.404" /><testcase classname="tests.text_extractor.test_views" name="test_submit_document_view[False-files0]" time="14.692" /><testcase classname="tests.text_extractor.test_views" name="test_submit_document_view[True-files1]" time="14.399" /><testcase classname="tests.text_extractor.test_views" name="test_submit_document_view[False-files2]" time="15.811" /><testcase classname="tests.text_extractor.test_views" name="test_submit_document_view[True-files3]" time="14.845" /><testcase classname="tests.text_extractor.test_views" name="test_download_document" time="15.007" /><testcase classname="tests.chat.test_chat_translate" name="test_translate_text_with_gemini" time="28.684" /><testcase classname="tests.otto.test_cleanup" name="test_delete_text_extractor_files_task" time="14.574" /><testcase classname="tests.test_performance.TestConcurrentOperations" name="test_concurrent_chat_creation" time="27.313" /><testcase classname="tests.test_performance.TestConcurrentOperations" name="test_concurrent_document_updates" time="20.196"><failure message="AttributeError: property 'title' of 'Document' object has no setter">self = &lt;tests.test_performance.TestConcurrentOperations object at 0x0000021C10FA9310&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3AF6DE40&gt;

    def test_concurrent_document_updates(self, basic_user):
        """Test concurrent updates to same document (race condition)"""
        user = basic_user()
        access_key = AccessKey(user=user)
    
        library = Library.objects.create(name="Race Condition Test")
    
        datasource = DataSource.objects.create(library=library,
            name="Race Condition Source")
    
&gt;       document = Document.objects.create(data_source=datasource,
            title="Concurrent Update Test")

django\tests\test_performance.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Document: Untitled document&gt;, args = (), kwargs = {'title': 'Concurrent Update Test'}
cls = &lt;class 'librarian.models.Document'&gt;, opts = &lt;Options for Document&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x0000021C3A5106D0&gt;, val = None
field = &lt;django.db.models.fields.CharField: pdf_extraction_method&gt;, is_related_object = False
rel_obj = &lt;DataSource: Race Condition Source&gt;
property_names = frozenset({'celery_status_message', 'content_type', 'display_cost', 'file_size', 'href', 'href_button', ...})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
&gt;                       _setattr(self, prop, value)
E                       AttributeError: property 'title' of 'Document' object has no setter

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\base.py:558: AttributeError</failure></testcase><testcase classname="tests.test_performance.TestConcurrentOperations" name="test_concurrent_permission_grants" time="47.799"><failure message="NameError: name 'LibraryUserRole' is not defined">self = &lt;tests.test_performance.TestConcurrentOperations object at 0x0000021C10E9FBB0&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3AF46480&gt;

    def test_concurrent_permission_grants(self, basic_user):
        """Test concurrent permission grants to same resource"""
        owner = basic_user(username="owner")
        users = [basic_user(username=f"user{i}") for i in range(5)]
    
        access_key = AccessKey(user=owner)
        library = Library.objects.create(name="Permission Test")
    
        def grant_permission(lib_id, user):
            """Grant view permission to user"""
            access_key = AccessKey(user=owner)
            lib = Library.objects.get(id=lib_id)
            LibraryUserRole.objects.create(library=lib, user=user, role="viewer")
            return True
    
        with PerformanceBenchmark("Concurrent permission grants") as bench:
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = [
                    executor.submit(grant_permission, library.id, user)
                    for user in users
                ]
&gt;               results = [f.result() for f in as_completed(futures)]
                           ^^^^^^^^^^

django\tests\test_performance.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lib_id = 1128, user = &lt;User: ,  (user0@example.com)&gt;

    def grant_permission(lib_id, user):
        """Grant view permission to user"""
        access_key = AccessKey(user=owner)
        lib = Library.objects.get(id=lib_id)
&gt;       LibraryUserRole.objects.create(library=lib, user=user, role="viewer")
        ^^^^^^^^^^^^^^^
E       NameError: name 'LibraryUserRole' is not defined

django\tests\test_performance.py:420: NameError</failure></testcase><testcase classname="tests.test_performance.TestStressScenarios" name="test_database_connection_pooling" time="14.758" /><testcase classname="tests.test_performance.TestCostTrackingPerformance" name="test_concurrent_cost_creation" time="14.885"><failure message="otto.models.CostType.MultipleObjectsReturned: get() returned more than one CostType -- it returned 4!">self = &lt;tests.test_performance.TestCostTrackingPerformance object at 0x0000021C10FA9A90&gt;
basic_user = &lt;function basic_user.&lt;locals&gt;.new_user at 0x0000021C3A51C220&gt;

    @pytest.mark.django_db(transaction=True)
    def test_concurrent_cost_creation(self, basic_user):
        """Test concurrent cost record creation"""
        user = basic_user()
    
        def create_cost_record(user_id, index):
            """Create a cost record"""
            from django.contrib.auth import get_user_model
            User = get_user_model()
            user = User.objects.get(id=user_id)
    
            Cost.objects.create(
                user=user,
                cost_type=CostType.objects.get_or_create(name="LLM", defaults={"unit_name": "tokens", "unit_cost": 0.00001, "unit_quantity": 1000})[0],
                count=1500,
                usd_cost=0.015
            )
            return True
    
        with PerformanceBenchmark("Concurrent cost creation") as bench:
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = [
                    executor.submit(create_cost_record, user.id, i)
                    for i in range(50)
                ]
&gt;               results = [f.result() for f in as_completed(futures)]
                           ^^^^^^^^^^

django\tests\test_performance.py:609: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
django\tests\test_performance.py:597: in create_cost_record
    cost_type=CostType.objects.get_or_create(name="LLM", defaults={"unit_name": "tokens", "unit_cost": 0.00001, "unit_quantity": 1000})[0],
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\modeltranslation\manager.py:420: in get_or_create
    return super().get_or_create(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:946: in get_or_create
    return self.get(**kwargs), False
           ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MultilingualQuerySet [&lt;CostType: GPT-4o Global (input)&gt;, &lt;CostType: GPT-4o Global (output)&gt;, &lt;CostType: OpenAI Embedd...ut)&gt;, &lt;CostType: o4-mini Global (input)&gt;, &lt;CostType: o4-mini Global (output)&gt;, '...(remaining elements truncated)...']&gt;
args = (), kwargs = {'name': 'LLM'}
clone = &lt;MultilingualQuerySet [&lt;CostType: LLM&gt;, &lt;CostType: LLM&gt;, &lt;CostType: LLM&gt;, &lt;CostType: LLM&gt;]&gt;, limit = 21, num = 4

    def get(self, *args, **kwargs):
        """
        Perform the query and return a single object matching the given
        keyword arguments.
        """
        if self.query.combinator and (args or kwargs):
            raise NotSupportedError(
                "Calling QuerySet.get(...) with filters after %s() is not "
                "supported." % self.query.combinator
            )
        clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)
        if self.query.can_filter() and not self.query.distinct_fields:
            clone = clone.order_by()
        limit = None
        if (
            not clone.query.select_for_update
            or connections[clone.db].features.supports_select_for_update_with_limit
        ):
            limit = MAX_GET_RESULTS
            clone.query.set_limits(high=limit)
        num = len(clone)
        if num == 1:
            return clone._result_cache[0]
        if not num:
            raise self.model.DoesNotExist(
                "%s matching query does not exist." % self.model._meta.object_name
            )
&gt;       raise self.model.MultipleObjectsReturned(
            "get() returned more than one %s -- it returned %s!"
            % (
                self.model._meta.object_name,
                num if not limit or num &lt; limit else "more than %s" % (limit - 1),
            )
        )
E       otto.models.CostType.MultipleObjectsReturned: get() returned more than one CostType -- it returned 4!

C:\Users\barre\AppData\Local\Programs\Python\Python313\Lib\site-packages\django\db\models\query.py:636: MultipleObjectsReturned</failure></testcase><testcase classname="tests.text_extractor.test_views" name="test_poll_tasks_view" time="14.857" /><testcase classname="tests.text_extractor.test_views" name="test_download_all_zip" time="14.964" /><testcase classname="laws.test_retriever_performance" name="test_retriever_performance" time="1.790" /></testsuite></testsuites>